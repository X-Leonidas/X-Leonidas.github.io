<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="计算机基础知识, XY的个人笔记">
    <meta name="description" content="XY的个人笔记">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>计算机基础知识 | XY的个人笔记</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 6.1.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">XY的个人笔记</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">XY的个人笔记</div>
        <div class="logo-desc">
            
            XY的个人笔记
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/11.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">计算机基础知识</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="post-category">
                                计算机基础
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-05-08
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>[TOC]</p>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><ul>
<li><p><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/%E5%86%AF%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84.png" alt="img"></p>
<p>冯诺依曼结构</p>
</li>
<li><p>VFS</p>
<ul>
<li>虚拟文件系统，目录树</li>
</ul>
</li>
<li><p>inode</p>
<ul>
<li>文件索引</li>
</ul>
</li>
<li><p>pageCache(页缓存)</p>
</li>
<li><p>FD文件描述符</p>
</li>
</ul>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li><p><strong>并行和并发</strong></p>
<ul>
<li>基本概念<br>并发：宏观上在一段时间内能同时运行多个程序<br> 并行：同一时刻能运行多个指令<br>  区别两者的关键：是否同时</li>
<li>并行需要硬件支持，多l流水线、分布式计算机，在计算机上的体现就是增加cpu的数量可以提高并行</li>
<li>操作系统引入进程和线程，使得程序可以并发运行</li>
</ul>
</li>
<li><p><strong>共享</strong></p>
<ul>
<li>共享是指系统中的资源可以被多个并发进程使用</li>
<li>有两种共享方式：互斥共享和同时共享</li>
<li>互斥共享的资源为临界资源，例如打印机，在同一时间只允许一个进程访问，需要用同步机制来实现对临界资源的访问</li>
</ul>
</li>
<li><p><strong>虚拟</strong></p>
<ul>
<li>虚拟技术把一个物理实体转换为多个逻辑实体</li>
<li>主要的虚拟技术：<ul>
<li>时分复用技术<em>time-multiplexed sharing</em></li>
<li>空分复用技术<em>space-multiplexed sharing</em></li>
</ul>
</li>
<li>时分复用技术是在“时间”上将资源分割成更小的单位供不同的进程使用，多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占有处理器，每次只执行一小个时间片并快速切换。</li>
<li>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</li>
</ul>
</li>
<li><p><strong>异步</strong></p>
<ul>
<li>异步是彼此独立， 在等待某事件的过程中去做另一件事情</li>
<li>异步是目的，多线程只是实现异步的一种手段，所以异步和多线程并不相同<h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2></li>
</ul>
</li>
<li><p>进程管理<br> 进程控制，进程同步，进程通信，死锁处理，处理调度</p>
</li>
<li><p>内存管理</p>
<ul>
<li>内存分配、地址映射、内存保护和共享、虚拟内存</li>
</ul>
</li>
<li><p>文件管理</p>
<ul>
<li>文件存储空间的管理、目录管理、文件读写管理和保护</li>
</ul>
</li>
<li><p>设备管理</p>
<ul>
<li>完成用户的I&#x2F;O请求，方便用户使用各种设备，并提高设备的利用率</li>
<li>主要包括缓冲管理、设备分配、设备处理、虚拟设备等<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2></li>
</ul>
</li>
<li><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p>
</li>
<li><img src="../pic/系统调用.png" style="zoom:60%;" />

<h3 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h3><ul>
<li>内核态（<em>Kernel Mode</em>）：CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. CPU也可以将自己从一个程序切换到另一个程序</li>
<li>用户态 (<em>User Mode</em>) : 只能受限的访问内存, 且不允许访问外围设备. 占用CPU的能力被剥夺, CPU资源可以被其他程序获取<h3 id="为什么有内核态和用户态？"><a href="#为什么有内核态和用户态？" class="headerlink" title="为什么有内核态和用户态？"></a>为什么有内核态和用户态？</h3></li>
<li>由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 – 用户态 和 内核态<h3 id="系统调用-内核切换"><a href="#系统调用-内核切换" class="headerlink" title="系统调用,内核切换"></a>系统调用,内核切换</h3></li>
<li>内核切换在CPU中的实现称之为陷阱指令(Trap Instruction)</li>
<li>内核调用：操作系统（内核）相当于是在应用程序和硬件之间添加了一个中间层。所以应用程序是不能够直接访问硬件设备的，只能使用内核向外提供的一组接口，这些接口让应用程序受限地访问硬件设备。我们把调用这些接口的过程叫做系统调用</li>
<li>工作流程<ol>
<li>用户态程序将一些数据值放在寄存器中, 或者使用参数创建一个堆栈(stack frame), 以此表明需要操作系统提供的服务.</li>
<li>用户态程序执行陷阱指令</li>
<li>CPU切换到内核态, 并跳到位于内存指定位置的指令, 这些指令是操作系统的一部分, 他们具有内存保护, 不可被用户态程序访问</li>
<li>这些指令称之为陷阱(trap)或者系统调用处理器(system call handler). 他们会读取程序放入内存的数据参数, 并执行程序请求的服务</li>
<li>系统调用完成后, 操作系统会重置CPU为用户态并返回系统调用的结果<h3 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h3></li>
</ol>
</li>
<li>外中断<br>由 CPU 执行指令以外的事件引起，如 I&#x2F;O 完成中断，表示设备输入&#x2F;输出处理已经完成，处理器能够发送下一个输入&#x2F;输出请求。此外还有时钟中断、控制台中断等。</li>
<li>异常<br>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</li>
<li>陷入<br>在用户程序中使用系统调用。</li>
</ul>
</li>
</ol>
<h2 id="大内核和微内核"><a href="#大内核和微内核" class="headerlink" title="大内核和微内核"></a>大内核和微内核</h2><ol>
<li>大内核<br>大内核系统将操作系统的主要内容模块都作为一个紧密联系的整体运行在核心态，从而为应用提供高性能的系统服务。因为各管理模块之间共享信息，能有效 利用相互之间的有效特性， 所以具有无可比拟的性能优势。</li>
<li>微内核<br>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。<h2 id="中断分类-1"><a href="#中断分类-1" class="headerlink" title="中断分类"></a>中断分类</h2></li>
<li>外中断<br>由 CPU 执行指令以外的事件引起，如 I&#x2F;O 完成中断，表示设备输入&#x2F;输出处理已经完成，处理器能够发送下一个输入&#x2F;输出请求。此外还有时钟中断、控制台中断等</li>
<li>异常<br>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等</li>
<li>陷入<br>在用户程序中使用系统调用。<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程、线程和协程"><a href="#进程、线程和协程" class="headerlink" title="进程、线程和协程"></a>进程、线程和协程</h2> 进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元<h3 id="1-进程"><a href="#1-进程" class="headerlink" title="1.进程"></a>1.进程</h3></li>
</ol>
<ul>
<li><p>进程是资源分配的基本单位</p>
</li>
<li><p>进程控制块(Process Control Block,PCB)描述进程的基本信息和运行状态,所谓的创建进程和撤销进程,都是指对PCB的操作</p>
</li>
<li><p>进程可以并发执行</p>
<h4 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h4></li>
<li><p>僵尸进程</p>
<ul>
<li>父进程产生子进程后，会维护子进程的一个PCB结构，子进程退出，由父进程释放，如果如进程没有释放，那么子进程成为一个僵尸进程</li>
</ul>
</li>
<li><p>孤儿进程</p>
<ul>
<li>子进程结束前，父进程已经退出。</li>
<li>孤儿进程会成为iinit进程的孩子，由1号进程维护。</li>
</ul>
</li>
</ul>
<h3 id="2-线程"><a href="#2-线程" class="headerlink" title="2.线程"></a>2.线程</h3><ul>
<li><p>线程是独立调度的基本单位</p>
</li>
<li><p>一个进程可以有多个线程,他们共享线程资源</p>
<h3 id="3-纤程-协程-Fiber"><a href="#3-纤程-协程-Fiber" class="headerlink" title="3.纤程(协程)Fiber"></a>3.纤程(协程)Fiber</h3></li>
<li><p>协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。<strong>协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程</strong>，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。</p>
</li>
<li><p>在协程中尽量不要调用阻塞IO的方法，比如打印，读取文件，Socket接口等，除非改为异步调用的方式，并且协程只有在IO密集型的任务中才会发挥作用。<strong>协程只有和异步IO结合起来才能发挥出最大的威力</strong></p>
</li>
<li><p>JAVA支持纤程的类库：quasar_core,GO、python支持</p>
</li>
</ul>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ul>
<li><p>资源<br>  <strong>进程是资源分配的基本单位</strong>,线程不拥有资源,线程访问隶属进程的资源</p>
</li>
<li><p>调度<br>  <strong>线程是独立调度的基本单位</strong>,在同一个进程中,线程的切换不会引起进程的切换,但一个进程中的线程切换到另一个进程中的线程,会引起线程切换</p>
</li>
<li><p>系统开销<br>  由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I&#x2F;O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p>
</li>
<li><p>通信方面<br>  线程间可以通过直接读写同一进程的数据进行通信,但进程间通信需要IPC</p>
<h2 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h2><img src="../pic/进程状态的切换.png" style="zoom:80%;" />
</li>
<li><p>就绪状态(ready):等待被调度</p>
</li>
<li><p>运行状态(running)</p>
</li>
<li><p>阻塞状态(waiting):等待资源<br>应该注意以下内容:</p>
<ul>
<li>只有就绪态和运行态可以相互转换,其他都是单向转换.就绪状态的进程通过调度算法从而获得CPU时间,转为运行状态;而运行状态的进程,在分配给他的CPU时间片用完之后就会转为就绪状态,等待下一次调用</li>
<li>阻塞状态是缺少需要的资源从而由运行状态转换而来,但是该资源不包括CPU时间,缺少CPU时间会从运行态转换为就绪态<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2></li>
</ul>
</li>
<li><p><strong>不同环境的调度算法不同,因此需要针对不同的环境来讨论调度算法</strong></p>
</li>
</ul>
<h3 id="进程调度策略"><a href="#进程调度策略" class="headerlink" title="进程调度策略"></a>进程调度策略</h3><ul>
<li><h3 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务(FCFS)"></a>先来先服务(FCFS)</h3><ul>
<li>先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</li>
</ul>
<h3 id="短作业-进程-优先-SJ-P-F"><a href="#短作业-进程-优先-SJ-P-F" class="headerlink" title="短作业(进程)优先(SJ(P)F)"></a><strong>短作业(进程)优先</strong>(SJ(P)F)</h3><ul>
<li>短作业(进程)优先调度算法SJ(P)F，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。</li>
</ul>
<h3 id="高优先权优先（FPF）"><a href="#高优先权优先（FPF）" class="headerlink" title="高优先权优先（FPF）"></a>高优先权优先（FPF）</h3><ul>
<li>为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。</li>
</ul>
<h4 id="非抢占式优先权"><a href="#非抢占式优先权" class="headerlink" title="非抢占式优先权"></a>非抢占式优先权</h4><ul>
<li>在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</li>
</ul>
<h4 id="抢占式优先权"><a href="#抢占式优先权" class="headerlink" title="抢占式优先权"></a>抢占式优先权</h4><ul>
<li>在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程i 时，就将其优先权Pi与正在执行的进程j 的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi&gt;Pj，则立即停止Pj的执行，做进程切换，使i 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</li>
</ul>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul>
<li><p>容易出现优先级倒置现象：优先级反转是指一个低优先级的任务持有一个被高优先级任务所需要的共享资源。高优先任务由于因资源缺乏而处于受阻状态，一直等到低优先级任务释放资源为止。而低优先级获得的CPU时间少，如果此时有优先级处于两者之间的任务，并且不需要那个共享资源，则该中优先级的任务反而超过这两个任务而获得CPU时间。如果高优先级等待资源时不是阻塞等待，而是忙循环，则可能永远无法获得资源，因为此时低优先级进程无法与高优先级进程争夺CPU时间，从而无法执行，进而无法释放资源，造成的后果就是高优先级任务无法获得资源而继续推进。</p>
</li>
<li><p>解决方案</p>
<ul>
<li>设置优先级上限，给临界区一个高优先级，进入临界区的进程都将获得这个高优先级，如果其他试图进入临界区的进程的优先级都低于这个高优先级，那么优先级反转就不会发生。</li>
<li>优先级继承，当一个高优先级进程等待一个低优先级进程持有的资源时，低优先级进程将暂时获得高优先级进程的优先级别，在释放共享资源后，低优先级进程回到原来的优先级别。嵌入式系统VxWorks就是采用这种策略。</li>
<li>临界区禁止中断，通过禁止中断来保护临界区，采用此种策略的系统只有两种优先级：可抢占优先级和中断禁止优先级。前者为一般进程运行时的优先级，后者为运行于临界区的优先级。火星探路者正是由于在临界区中运行的气象任务被中断发生的通信任务所抢占才导致故障，如果有临界区的禁止中断保护，此一问题也不会发生。</li>
</ul>
</li>
</ul>
<h3 id="高响应比优先"><a href="#高响应比优先" class="headerlink" title="高响应比优先"></a>高响应比优先</h3><ul>
<li><p>在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：</p>
<ul>
<li><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png" alt="高响应比优先调度算法"></li>
</ul>
</li>
<li><p>在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。</p>
</li>
</ul>
<h3 id="时间片轮转法"><a href="#时间片轮转法" class="headerlink" title="时间片轮转法"></a>时间片轮转法</h3><ul>
<li>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言之，系统能在给定的时间内响应所有用户的请求。</li>
</ul>
<h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><ul>
<li>前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述。<ul>
<li>应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。</li>
<li>当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。</li>
<li>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。</li>
</ul>
</li>
</ul>
<h3 id="批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？"><a href="#批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？" class="headerlink" title="批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？"></a><strong>批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？</strong></h3><ul>
<li>批处理系统常用调度算法：<ul>
<li>先来先服务</li>
<li>最短作业优先</li>
<li>最短剩余时间优先</li>
<li>响应比最高者优先</li>
</ul>
</li>
<li>分时系统调度算法：<ul>
<li>轮转调度</li>
<li>优先级调度</li>
<li>多级队列调度</li>
<li>彩票调度</li>
</ul>
</li>
<li>实时系统调度算法：<ul>
<li>单比率调度</li>
<li>限期调度</li>
<li>最少裕度法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Linux调度算法CFS"><a href="#Linux调度算法CFS" class="headerlink" title="Linux调度算法CFS"></a>Linux调度算法CFS</h3><ul>
<li>2.6后开始采用该算法，该算法按优先级分配时间片的比例，记录每个线程的执行时间，如果有一个进程执行时间不到它分配的比例，则优先执行该进程</li>
<li>对于实时进程：使用SCHED_FIFO和SCHED_RR(Round Robin)两种，对于普通进程使用CFS,等级最高的为FIIO,这种进程除非自己让出CPU或者被更高级别的FIFO或RR抢占,否则Linux会一直执行它。RR只是这种线程中的同级别FIFO的平均分配。只有实时进程主动让出或执行完毕后，普通进程才有机会执行。</li>
</ul>
<h3 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h3><p><strong>批处理系统没有太多的用户操作,在该系统中,调度算法目标是保证吞吐量和周转时间(从提交到终止的时间)</strong></p>
<ul>
<li>1.1 先来先服务(first-come first-serverd(FCFS )<br>按照请求的顺序进行调度。<br>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</li>
<li>1.2 短作业优先(shortest job first(SJF))<br>按估计运行时间最短的顺序进行调度</li>
<li>1.3 最短剩余时间优先(shortest remaining time next (SRTN))<br>按估计剩余时间最短的顺序进行排序<h3 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h3><strong>交互式系统有大量的用户交互操作,在该系统中调度算法的目标是快速地进行响应</strong></li>
<li>2.1 时间片轮转<br>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。<br>时间轮转算法的效率和时间片的大小有很大的关系<ul>
<li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间</li>
<li>而如果时间片时间太长,那么实时性就得不到保证</li>
</ul>
</li>
<li>2.2 优先级调度<br>为每个进程分配一个优先级,按优先级进行调度<br>为了防止优先级低的进程永远得不到调度,可以随着时间的推移增加等待进程的优先级</li>
<li>2.3 多级反馈队列<br>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。<br>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。<br>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。<h2 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h2>实时系统要求一个请求在一个确定的时间内得到响应分为y硬实时和软实时,前者必须满足绝对的截止时间,后者可以容忍一定的超时</li>
</ul>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><ul>
<li>硬中断</li>
<li>软中断</li>
</ul>
<h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><h2 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1. 临界区"></a>1. 临界区</h2><p>每个进程中,对临界资源进行访问的代码称为临界区(临界资源是一次仅允许一个进程使用的共享资源)<br>为了互斥访问临界区资源,每个进程在进入临界区之前,需要先进行检查.</p>
<h2 id="2-同步和互斥"><a href="#2-同步和互斥" class="headerlink" title="2.同步和互斥"></a>2.同步和互斥</h2><ul>
<li>同步:多个线程按一定顺序执行</li>
<li>互斥:多个线程在同一时刻只有一个线程能进入临界区<h2 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3.信号量"></a>3.信号量</h2></li>
<li>信号量(Semaphore)是一个整形变量,可以对其执行down和up操作,也就是常见的P和V操作<ul>
<li>down:如果信号量大于0,执行-1操作;如果信号量等于0,j进程睡眠,等待信号量大于0.</li>
<li>up:对信号量执行+1操作,唤醒睡眠的进程让其完成down操作.</li>
</ul>
</li>
<li>down 和 up 操作需要被设计成原语,通常的做法是执行这些操作时,屏蔽中断.如果信号量只有1和0,那么就成为了互斥量(Mutex),0表示临界区已经枷锁,1表示临界区已经解锁</li>
</ul>
<blockquote>
<p>原语:若干个机器指令构成的完成某种特定功能的一段程序，具有不可分割性·即原语的执行必须是连续的，在执行过程中不允许被中断。</p>
</blockquote>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typedef int semaphore;
semaphore mutex &#x3D; 1;
void P1() &#123;
    down(&amp;mutex);
    &#x2F;&#x2F; 临界区
    up(&amp;mutex);
&#125;

void P2() &#123;
    down(&amp;mutex);
    &#x2F;&#x2F; 临界区
    up(&amp;mutex);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="使用信号量实现生产者-消费者问题"><a href="#使用信号量实现生产者-消费者问题" class="headerlink" title="使用信号量实现生产者 - 消费者问题"></a>使用信号量实现生产者 - 消费者问题</h3><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p>
<ul>
<li>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</li>
<li>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty &#x3D; 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#define N 100
typedef int semaphore;
semaphore mutex &#x3D; 1;
semaphore empty &#x3D; N;
semaphore full &#x3D; 0;

void producer() &#123;
    while(TRUE) &#123;
        int item &#x3D; produce_item();
        down(&amp;empty);
        down(&amp;mutex);
        insert_item(item);
        up(&amp;mutex);
        up(&amp;full);
    &#125;
&#125;

void consumer() &#123;
    while(TRUE) &#123;
        down(&amp;full);
        down(&amp;mutex);
        int item &#x3D; remove_item();
        consume_item(item);
        up(&amp;mutex);
        up(&amp;empty);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3></li>
<li>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</li>
<li>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。<pre class="line-numbers language-Pascal" data-language="Pascal"><code class="language-Pascal">    monitor ProducerConsumer
    integer i;
    condition c;

    procedure insert();
    begin
        &#x2F;&#x2F; ...
    end;

    procedure remove();
    begin
        &#x2F;&#x2F; ...
    end;
end monitor;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2></li>
<li>读者-写者问题<br>  允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</li>
<li>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</li>
</ul>
<pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">typedef int semaphore;
&#x2F;&#x2F;互斥量,对count加锁
semaphore count_mutex &#x3D; 1;
&#x2F;&#x2F;互斥量,对读写的数据加锁
semaphore data_mutex &#x3D; 1;
&#x2F;&#x2F;进行读操作的进程数量
int count &#x3D; 0;

void reader() &#123;
    while(TRUE) &#123;
        down(&amp;count_mutex);
        count++;
        if(count &#x3D;&#x3D; 1) down(&amp;data_mutex); &#x2F;&#x2F; 第一个读者需要对数据进行加锁，防止写进程访问
        up(&amp;count_mutex);
        read();
        down(&amp;count_mutex);
        count--;
        if(count &#x3D;&#x3D; 0) up(&amp;data_mutex);
        up(&amp;count_mutex);
    &#125;
&#125;

void writer() &#123;
    while(TRUE) &#123;
        down(&amp;data_mutex);
        write();
        up(&amp;data_mutex);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><ul>
<li>进程同步与进程通信很容易混淆，它们的区别在于：<ol>
<li>进程同步：控制多个进程按一定顺序执行；</li>
<li>进程通信：进程间传输信息。</li>
</ol>
</li>
<li>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。<h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1. 管道"></a>1. 管道</h3></li>
<li>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。<ul>
<li>pipe函数:linux中</li>
</ul>
</li>
<li>限制:<ul>
<li>只支持半双工通信(单向交替传输)</li>
<li>只能在父子进程中使用<img src="../pic/管道.png"/>
### 2.FIFO</li>
</ul>
</li>
<li>也成为命名管道,去除了管道只能在父子线程中使用的限制<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;sys&#x2F;stat.h&gt;int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li>FIFO常用于客户-服务器应用程序中,FIFO用作汇聚点,在客户进程和服务器进程之间传递数据<img src="../pic/FIFO.png" style="zoom:75%;" />
### 3.消息队列</li>
<li>相比于FIFO,消息队列具有以下特点<ul>
<li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li>
<li>避免了FIFO的同步阻塞问题,不需要进程自己提供同步方法</li>
<li>读进程可以根据消息类型有选择地接收消息,而不像FIFO那样只能默认地接收<h3 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4.信号量"></a>4.信号量</h3>它是一个计数器,用于为多个进程提供共享数据对象的访问<h3 id="5-共享存储"><a href="#5-共享存储" class="headerlink" title="5.共享存储"></a>5.共享存储</h3></li>
</ul>
</li>
<li>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</li>
<li>需要使用信号量用来同步对共享存储的访问。</li>
<li>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用使用内存的匿名段.<h3 id="6-套接字"><a href="#6-套接字" class="headerlink" title="6.套接字"></a>6.套接字</h3></li>
<li>与其它通信机制不同的是，它可用于不同机器间的进程通信。</li>
</ul>
<h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><ul>
<li><p>一个良好的计算机程序 常常具有良好的局部性，也就是说，它们倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身</p>
</li>
<li><p>时间局部性</p>
<ul>
<li>时间局部性是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。强调数据的重复访问。利用时间局部性，缓存在现代程序系统中扮演着重要角色，数据缓存，磁盘缓存，文件缓存等，极大提高数据的重复访问性能。</li>
</ul>
</li>
<li><p>空间局部性</p>
<ul>
<li>空间局部性是指一旦程序访问了某个存储单元，则不久之后。其附近的存储单元也将被访问。强调连续空间数据的访问，一般顺序访问每个元素（步长为1）时具有最好的空间局部性，步长越大，空间局部性越差。</li>
</ul>
</li>
</ul>
<h2 id="磁盘预读"><a href="#磁盘预读" class="headerlink" title="磁盘预读"></a>磁盘预读</h2><ul>
<li>计算机系统是分页读取和存储的，一般一页为4kb,每次读取和存储的最小单元为一页，而<strong>磁盘预读时通常会读取页的整倍数</strong></li>
</ul>
<h2 id="存储层次"><a href="#存储层次" class="headerlink" title="存储层次"></a>存储层次</h2><ul>
<li><p><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1.png" alt="img"></p>
</li>
<li><p>寄存器：最快的访问</p>
</li>
<li><p>高速缓存(L1~L3:SRAM):高速缓存钟的访问速度为纳秒级，非常快</p>
<ul>
<li>第一级高速缓存（L1）：通常访问只需要几个周期，通常是几十个kb</li>
<li>第二级高速缓存（L2）：比L1约有2到10倍较高延迟性，通常是几百个kb或更多</li>
<li>第三级高速缓存（L3）：不一定有，比L2更高的延迟性，通常由数MB之大</li>
<li>第四级高速缓存（L4）：不普遍，CPU外部的DRAM，但速度较主存高</li>
</ul>
</li>
<li><p>主存(DRAM)：访问需要几百个周期，容量非常大，持久化保存数据</p>
</li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><ul>
<li><p>为了解决互相打扰的问题</p>
<ul>
<li>虚拟空间多大：寻址空间—-64位系统 2^64byte</li>
<li>内存映射：偏移量+段的基地址&#x3D;线性地址（虚拟空间）</li>
<li>线性地址通过OS和MMU（Merory Management Unit）来映射到真正的物理地址</li>
</ul>
</li>
<li><p>特征</p>
<ul>
<li>一个以上的虚拟地址可以指向同一个物理内存地址。</li>
<li>虚拟内存空间可大于实际可用的物理地址。</li>
</ul>
</li>
<li><p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>
</li>
<li><p>虚拟内存被分为用户空间和内核空间两部分，当我们在用户态的时候，只能访问用户空间。只有进入内核态，才能访问内核空间</p>
</li>
</ul>
<h4 id="虚拟页"><a href="#虚拟页" class="headerlink" title="虚拟页"></a>虚拟页</h4><ul>
<li>把内存分成固定大小的页框(4k) ,把硬盘上的程序也分成4k大小的块，用到那一块加载那一块，加载过程中，如果内存已满，会把最不常用的一块放到swap分区。（LRU算法 Least Recently Used 力扣146）</li>
<li>系统将虚拟内存分割为称为虚拟页(Virtual Page,VP)的大小固定的块，每个虚拟页的大小为P &#x3D; 2^p字节，类似地，物理内存被分割为物理页(Physical Page,PP)，大小也为P字节（物理页也称为页帧(page frame)）。</li>
<li>任意时刻，虚拟页面都分为互不相交的三种：<ul>
<li>未分配的：系统还未分配（或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间</li>
<li>未缓存的：没有缓存在物理存储器中的已分配页</li>
<li>缓存的：当前缓存在物理存储器中的已分配页</li>
</ul>
</li>
</ul>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><ul>
<li><p>页表是一种特殊的数据结构，存放着各个虚拟页的状态，是否映射，是否缓存.。</p>
</li>
<li><p>页表的每一个表项分为两部分，</p>
<ul>
<li>第一部分记录此页是否在物理内存上</li>
<li>第二部分记录物理内存页的地址(如果在的话)。当进程访问某个虚拟地址，就会先去看页表，如果发现对应的数据不在物理内存中，则发生<strong>缺页异常</strong>。</li>
</ul>
</li>
<li><p><img src="/../pic/v2-bfdac094ce8bea2ddc2838ed94a8ff90_720w.jpg" alt="img"></p>
</li>
<li><p>图中展示了一个页表的基本组织结构，页表就是一个页表条目(Page Table Entry,PTE)的数组，每个PTE由一个有效位(valid bit)和一个地址组成，有效位表明了该虚拟页当前是否存在于物理内存中，如果有效位是1，该PTE中就会存储物理内存中相应的物理页的起始地址。如果有效位是0，且PTE中的地址为null，这表示这个虚拟页还未被分配，而如果有效位是0且PTE中有地址，那么这个地址指向该虚拟页在磁盘上的起始位置</p>
<p>上图的示例展示了一个有8个虚拟页和4个物理页的系统的页表，四个虚拟页（VP1、VP2、VP4和VP7）当前存储于物理内存中，两个页（VP0和VP5）还未被分配（也就是什么都没存的虚拟内存，在磁盘和物理内存中都不存在这个空间），而剩下的页（VP3和VP6）已经被分配了，但是还未缓存进物理内存（也就是存在于磁盘上）</p>
<p>在上面的过程中，CPU读包含在VP1中的一个数据时，地址翻译硬件将虚拟地址作为一个索引找到页表中的PTE 2，然后再从PTE 2中保存的物理地址从真正的物理内存中读到这个数据，在有效位为1的PTE中成功找到对应的物理页就称之为页命中</p>
</li>
</ul>
<h4 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h4><ul>
<li>调用内核缺页异常处理程序。内核通过页面置换算法选择一个页面作为被覆盖的页面，将该页的内容刷新到磁盘空间当中。然后把VP3映射的磁盘文件缓存到该物理页上面。然后页表中第三条，有效位变成1，第二部分存储上了可以对应物理内存页的地址的内容。</li>
</ul>
<h2 id="CPUCache"><a href="#CPUCache" class="headerlink" title="CPUCache"></a>CPUCache</h2><ul>
<li>CPU Cache 通常分为三级缓存：L1 Cache、L2 Cache、L3 Cache，级别越低的离 CPU 核心越近，访问速度也快，但是存储容量相对就会越小。其中，在多核心的 CPU 里，每个核心都有各自的 L1&#x2F;L2 Cache，而 L3 Cache 是所有核心共享使用的。</li>
</ul>
<img src="../pic/CPUCache.png" alt="CPUCache" style="zoom:50%;" />

<ul>
<li>CPU Cache 是由很多个 Cache Line 组成的，CPU Line 是 CPU 从内存读取数据的基本单位，而 CPU Line 是由各种标志（Tag）+ 数据块（Data Block）组成</li>
</ul>
<h3 id="CacheLine"><a href="#CacheLine" class="headerlink" title="CacheLine"></a>CacheLine</h3><ul>
<li><img src="../pic/CacheLine.png" alt="CacheLine" style="zoom: 50%;" /></li>
<li>CPU Line 是 CPU 从内存读取数据的基本单位，而 CPU Line 是由各种标志（Tag）+ 数据块（Data Block）组成</li>
</ul>
<h3 id="写直达"><a href="#写直达" class="headerlink" title="写直达"></a>写直达</h3><ul>
<li><p>保持内存与 Cache 一致性最简单的方式是，<strong>把数据同时写入内存和 Cache 中</strong>，这种方法称为<strong>写直达（*Write Through*）</strong>。</p>
</li>
<li><p>在这个方法里，写入前会先判断数据是否已经在 CPU Cache 里面了：</p>
<ul>
<li>如果数据已经在 Cache 里面，先将数据更新到 Cache 里面，再写入到内存里面；</li>
<li>如果数据没有在 Cache 里面，就直接把数据更新到内存里面。</li>
</ul>
</li>
<li><p>写直达法很直观，也很简单，但是问题明显，无论数据在不在 Cache 里面，每次写操作都会写回到内存，这样写操作将会花费大量的时间，无疑性能会受到很大的影响。</p>
</li>
</ul>
<h3 id="写回"><a href="#写回" class="headerlink" title="写回"></a>写回</h3><ul>
<li><strong>当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block「被替换」时才需要写到内存中</strong></li>
<li>如果当发生写操作时，数据已经在 CPU Cache 里的话，则把数据更新到 CPU Cache 里，同时标记 CPU Cache 里的这个 Cache Block 为脏（Dirty）的，这个脏的标记代表这个时候，我们 CPU Cache 里面的这个 Cache Block 的数据和内存是不一致的，这种情况是不用把数据写到内存里的；</li>
<li>如果当发生写操作时，数据所对应的 Cache Block 里存放的是「别的内存地址的数据」的话，就要检查这个 Cache Block 里的数据有没有被标记为脏的，如果是脏的话，我们就要把这个 Cache Block 里的数据写回到内存，然后再把当前要写入的数据，写入到这个 Cache Block 里，同时也把它标记为脏的；如果 Cache Block 里面的数据没有被标记为脏，则就直接将数据写入到这个 Cache Block 里，然后再把这个 Cache Block 标记为脏的就好了。</li>
</ul>
<h3 id="写传播"><a href="#写传播" class="headerlink" title="写传播"></a>写传播</h3><ul>
<li>某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为<strong>写传播（*Wreite Propagation*）</strong></li>
</ul>
<h3 id="事务串行化"><a href="#事务串行化" class="headerlink" title="事务串行化"></a>事务串行化</h3><ul>
<li>某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为<strong>事务的串形化（*Transaction Serialization*）</strong>。</li>
<li>解释<ul>
<li>假设我们有一个含有 4 个核心的 CPU，这 4 个核心都操作共同的变量 i（初始值为 0 ）。A 号核心先把 i 值变为 100，而此时同一时间，B 号核心先把 i 值变为 200，这里两个修改，都会「传播」到 C 和 D 号核心。</li>
<li><img src="../pic/事务串行化.png" alt="事务串行化" style="zoom: 50%;" /></li>
<li>那么问题就来了，C 号核心先收到了 A 号核心更新数据的事件，再收到 B 号核心更新数据的事件，因此 C 号核心看到的变量 i 是先变成 100，后变成 200。</li>
<li>而如果 D 号核心收到的事件是反过来的，则 D 号核心看到的是变量 i 先变成 200，再变成 100，虽然是做到了写传播，但是各个 Cache 里面的数据还是不一致的。</li>
<li>所以，我们要保证 C 号核心和 D 号核心都能看到<strong>相同顺序的数据变化</strong>，比如变量 i 都是先变成 100，再变成 200，这样的过程就是事务的串形化。</li>
<li>要实现事务串形化，要做到 2 点：<ul>
<li>CPU 核心对于 Cache 中数据的操作，需要同步给其他 CPU 核心；</li>
<li>要引入「锁」的概念，如果两个 CPU 核心里有相同数据的 Cache，那么对于这个 Cache 数据的更新，只有拿到了「锁」，才能进行对应的数据更新。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总线嗅探"><a href="#总线嗅探" class="headerlink" title="总线嗅探"></a>总线嗅探</h3><ul>
<li>写传播的原则就是当某个 CPU 核心更新了 Cache 中的数据，要把该事件广播通知到其他核心。最常见实现的方式是<strong>总线嗅探（*Bus Snooping*）</strong>。</li>
</ul>
<h3 id="缓存一致性协议：MESI"><a href="#缓存一致性协议：MESI" class="headerlink" title="缓存一致性协议：MESI"></a>缓存一致性协议：MESI</h3><ol>
<li><p>概念：**<code>MESI</code>**（<code>Modified Exclusive Shared Or Invalid</code>）(也称为伊利诺斯协议，是因为该协议由伊利诺斯州立大学提出）是一种广泛使用的支持写回策略的缓存一致性协议</p>
</li>
<li><p>MESI的状态</p>
<p>CPU中每个缓存行（<code>caceh line</code>)使用4种状态进行标记（使用额外的两位(<code>bit</code>)表示):</p>
<p><img src="/../pic/1014100-20180613224959895-380715655.gif" alt="img"></p>
<ol>
<li><p><strong>M: 被修改（Modified)</strong></p>
<p>该缓存行只被缓存在该<code>CPU</code>的缓存中，并且是被修改过的（<code>dirty</code>),即与主存中的数据不一致，该缓存行中的内存需要在未来的某个时间点（允许其它<code>CPU</code>读取请主存中相应内存之前）写回（<code>write back</code>）主存。</p>
<p>当被写回主存之后，该缓存行的状态会变成独享（<code>exclusive</code>)状态</p>
</li>
<li><p><strong>E:独占的(Exclusive)</strong></p>
<p>该缓存行只被缓存在该<code>CPU</code>的缓存中，它是未被修改过的（<code>clean</code>)，与主存中数据一致。该状态可以在任何时刻当有其它<code>CPU</code>读取该内存时变成共享状态（<code>shared</code>)。</p>
<p>同样地，当<code>CPU</code>修改该缓存行中内容时，该状态可以变成<code>Modified</code>状态</p>
</li>
<li><p><strong>S:共享的(Shared)</strong><br>该状态意味着该缓存行可能被多个<code>CPU</code>缓存，并且各个缓存中的数据与主存数据一致（<code>clean</code>)，当有一个<code>CPU</code>修改该缓存行中，其它<code>CPU</code>中该缓存行可以被作废（变成无效状态（<code>Invalid</code>））</p>
</li>
<li><p><strong>无效的(Invalid)</strong></p>
<p>该缓存是无效的（可能有其它<code>CPU</code>修改了该缓存行）。</p>
</li>
<li><p><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/1014100-20180613225133544-1986197420.png" alt="img"></p>
</li>
</ol>
</li>
<li><p>解释</p>
<ol>
<li><p>在一个典型系统中，可能会有几个缓存（在多核系统中，每个核心都会有自己的缓存）共享主存总线，每个相应的<code>CPU</code>会发出读写请求，而缓存的目的是为了减少<code>CPU</code>读写共享主存的次数。</p>
</li>
<li><p>一个缓存除在<code>Invalid</code>状态外都可以满足cpu的读请求，一个<code>Invalid</code>的缓存行必须从主存中读取（变成<code>S</code>或者 <code>E</code>状态）来满足该<code>CPU</code>的读请求。</p>
</li>
<li><p>一个写请求只有在该缓存行是M或者E状态时才能被执行，如果缓存行处于<code>S</code>状态，必须先将其它缓存中该缓存行变成<code>Invalid</code>状态（也既是不允许不同<code>CPU</code>同时修改同一缓存行，即使修改该缓存行中不同位置的数据也不允许）。该操作经常作用广播的方式来完成，例如：<code>RequestFor Ownership</code> (<code>RFO</code>)。</p>
</li>
<li><p>缓存可以随时将一个非M状态的缓存行作废，或者变成<code>Invalid</code>状态，而一个<code>M</code>状态的缓存行必须先被写回主存。</p>
</li>
<li><p>一个处于<code>M</code>状态的缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S状态之前被延迟执行。</p>
</li>
<li><p>一个处于S状态的缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（<code>Invalid</code>）。</p>
</li>
<li><p>一个处于E状态的缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成<code>S</code>状态。</p>
</li>
<li><p>对于<code>M</code>和<code>E</code>状态而言总是精确的，他们在和该缓存行的真正状态是一致的。而<code>S</code>状态可能是非一致的，如果一个缓存将处于<code>S</code>状态的缓存行作废了，而另一个缓存实际上可能已经独享了该缓存行，但是该缓存却不会将该缓存行升迁为<code>E</code>状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的<code>copy</code>的数量，因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。</p>
<p>从上面的意义看来E状态是一种投机性的优化：如果一个<code>CPU</code>想修改一个处于<code>S</code>状态的缓存行，总线事务需要将所有该缓存行的<code>copy</code>变成<code>Invalid</code>状态，而修改<code>E</code>状态的缓存不需要使用总线事务</p>
</li>
</ol>
</li>
</ol>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><h3 id="四次拷贝的情况"><a href="#四次拷贝的情况" class="headerlink" title="四次拷贝的情况"></a>四次拷贝的情况</h3><ul>
<li><img src="/../pic/%E5%9B%9B%E6%AC%A1%E6%8B%B7%E8%B4%9D%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="img"></li>
</ul>
<h3 id="零拷贝的两种实现方式"><a href="#零拷贝的两种实现方式" class="headerlink" title="零拷贝的两种实现方式"></a>零拷贝的两种实现方式</h3><h4 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap+write"></a>mmap+write</h4><ul>
<li>mmap<ul>
<li>在LINUX中我们可以使用mmap用来在进程虚拟内存地址空间中分配地址空间，创建和物理内存的映射关系</li>
<li><img src="/../pic/mmap%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="img"></li>
<li>使用mmap后的文件拷贝流程</li>
<li><img src="/../pic/mmap%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E6%B5%81%E7%A8%8B.png" alt="img"></li>
<li>应用进程调用了 <code>mmap()</code> 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；</li>
<li>应用进程再调用 <code>write()</code>，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；</li>
<li>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</li>
</ul>
</li>
</ul>
<h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h4><ul>
<li>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 <code>sendfile()</code>,<ul>
<li>它可以替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用</li>
<li>该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝</li>
</ul>
</li>
<li><img src="/../pic/sendfile%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E6%B5%81%E7%A8%8B1.png" alt="img"></li>
</ul>
<h4 id="SG-DMA"><a href="#SG-DMA" class="headerlink" title="SG-DMA"></a><strong>SG-DMA</strong></h4><ul>
<li><p>但是这还<strong>不是真正的零拷贝技术</strong>，如果网卡支持 <strong>SG-DMA</strong>（The Scatter-Gather Direct Memory Access）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。</p>
</li>
<li><p>ethtool -k eth0  | grep scatter-gather    :查明是否支持scatter-gather</p>
</li>
<li><p>从 Linux 内核 <code>2.4</code> 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， <code>sendfile()</code> 系统调用的过程发生了点变化，具体过程如下:</p>
<ul>
<li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li>
<li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li>
</ul>
</li>
<li><p><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/sendfile%25E6%2596%2587%25E4%25BB%25B6%25E6%258B%25B7%25E8%25B4%259D%25E6%25B5%2581%25E7%25A8%258B2.png"></p>
</li>
<li><p><strong>零拷贝（*Zero-copy*）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</strong></p>
</li>
<li><p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，<strong>只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p>
<p>所以，总体来看，<strong>零拷贝技术可以把文件传输的性能提高至少一倍以上</strong>。</p>
</li>
</ul>
<h3 id="大文件传输"><a href="#大文件传输" class="headerlink" title="大文件传输"></a>大文件传输</h3><ul>
<li><p>针对大文件的传输，不应该使用 PageCache，也就是说不应该使用零拷贝技术，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，这样在高并发的环境下，会带来严重的性能问题</p>
</li>
<li><p><strong>在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I&#x2F;O + 直接 I&#x2F;O」来替代零拷贝技术</strong>。</p>
</li>
</ul>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">xy</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://x-leonidas.github.io/2022/05/08/01-cao-zuo-xi-tong/cao-zuo-xi-tong-ji-chu-zhi-shi/">https://x-leonidas.github.io/2022/05/08/01-cao-zuo-xi-tong/cao-zuo-xi-tong-ji-chu-zhi-shi/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">xy</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2022/05/08/01-cao-zuo-xi-tong/cao-zuo-xi-tong-ji-chu-zhi-shi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/11.jpg" class="responsive-img" alt="计算机基础知识">
                        
                        <span class="card-title">计算机基础知识</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-05-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="post-category">
                                    计算机基础
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                本篇&nbsp;<i class="far fa-dot-circle"></i>
            </div>
            <div class="card">
                <a href="/2022/05/08/01-cao-zuo-xi-tong/cao-zuo-xi-tong-ji-chu-zhi-shi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/11.jpg" class="responsive-img" alt="计算机基础知识">
                        
                        <span class="card-title">计算机基础知识</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-05-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="post-category">
                                    计算机基础
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: XY的个人笔记<br />'
            + '文章作者: XY<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('2'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <span id="year">2019</span>
            <a href="/about" target="_blank">XY</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">














</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
