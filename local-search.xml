<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>哈希</title>
    <link href="/2022/05/13/02-shu-ju-jie-gou/ha-xi/"/>
    <url>/2022/05/13/02-shu-ju-jie-gou/ha-xi/</url>
    
    <content type="html"><![CDATA[<h3 id="经典哈希函数特性"><a href="#经典哈希函数特性" class="headerlink" title="经典哈希函数特性"></a>经典哈希函数特性</h3><ul><li>输入域是无穷大的，输出域是有限的</li><li>固定的输入，返回的输出hashCode也是固定的</li><li>必然有不同的输入相同的输出</li><li>哈希函数具有离散性</li></ul><h3 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h3><ul><li>将hash结构做成环状，为了减少扩容哈希桶时，数据迁移的成本</li><li>为了解决哈希算法中，取模为固定的数，无法扩展的缺点，采用一致性哈希算法，在一致性哈希算法中，为了避免当某个节点下线时，该节点所负责的数据不可用，通常设计为环状，几个节点为物理节点。</li></ul><h5 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h5><ul><li>解决数据倾斜的问题（环被分的不平均）</li><li>不用真实ip去分配节点，而是为每个ip分配多个虚拟节点</li></ul><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><ul><li>作用<ul><li>快速的查找两个元素是否属于一个集合</li><li>两个元素各自所在的集合，将两个集合合并</li></ul></li></ul><h3 id="解决hash冲突的方法"><a href="#解决hash冲突的方法" class="headerlink" title="解决hash冲突的方法"></a>解决hash冲突的方法</h3><h4 id="再散列方法（开放地址法）"><a href="#再散列方法（开放地址法）" class="headerlink" title="再散列方法（开放地址法）"></a>再散列方法（开放地址法）</h4><h5 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h5><ul><li><p>冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。</p></li><li><p><strong>优点：</strong>易于实施；总是找到一个位置（如果有）；当表不是很满时，平均情况下的性能非常好。</p></li><li><p><strong>缺点：</strong>表的相邻插槽中会形成“集群”或“集群”键；当这些簇填满整个阵列的大部分时，性能会严重下降，因为探针序列执行的工作实际上是对大部分阵列的穷举搜索。</p></li></ul><h5 id="随机散列"><a href="#随机散列" class="headerlink" title="随机散列"></a>随机散列</h5><ul><li><p>di&#x3D;伪随机数序列。</p><p>具体实现时，应建立一个伪随机数发生器，（如i&#x3D;(i+p) % m），并给定一个随机数做起点。</p><p>例如，已知哈希表长度m&#x3D;11，哈希函数为：H（key）&#x3D; key % 11，则H（47）&#x3D;3，H（26）&#x3D;4，H（60）&#x3D;5，假设下一个关键字为69，则H（69）&#x3D;3，与47冲突。</p><p>如果用线性探测再散列处理冲突，下一个哈希地址为H1&#x3D;（3 + 1）% 11 &#x3D; 4，仍然冲突，再找下一个哈希地址为H2&#x3D;（3 + 2）% 11 &#x3D; 5，还是冲突，继续找下一个哈希地址为H3&#x3D;（3 + 3）% 11 &#x3D; 6，此时不再冲突，将69填入5号单元。</p><p>如果用二次探测再散列处理冲突，下一个哈希地址为H1&#x3D;（3 + 12）% 11 &#x3D; 4，仍然冲突，再找下一个哈希地址为H2&#x3D;（3 - 12）% 11 &#x3D; 2，此时不再冲突，将69填入2号单元。</p><p>如果用伪随机探测再散列处理冲突，且伪随机数序列为：2，5，9，……..，则下一个哈希地址为H1&#x3D;（3 + 2）% 11 &#x3D; 5，仍然冲突，再找下一个哈希地址为H2&#x3D;（3 + 5）% 11 &#x3D; 8，此时不再冲突，将69填入8号单元。</p></li></ul><h4 id="双重哈希"><a href="#双重哈希" class="headerlink" title="双重哈希"></a>双重哈希</h4><ul><li>这种方法是同时构造多个不同的哈希函数：Hi&#x3D;RH1（key） i&#x3D;1，2，…，k。当哈希地址Hi&#x3D;RH1（key）发生冲突时，再计算Hi&#x3D;RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</li></ul><h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><ul><li>这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</li></ul><h4 id="建立公共溢出区"><a href="#建立公共溢出区" class="headerlink" title="建立公共溢出区"></a>建立公共溢出区</h4><p>这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p><h4 id="拉链法与开放地址法相比的缺点"><a href="#拉链法与开放地址法相比的缺点" class="headerlink" title="拉链法与开放地址法相比的缺点"></a>拉链法与开放地址法相比的缺点</h4><ul><li><p><strong>拉链法的优点</strong></p><p><strong>与开放定址法相比，拉链法有如下几个优点：</strong></p><p>①拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；</p><p>②由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；</p><p>③开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；</p><p>④在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。</p><p><strong>拉链法的缺点</strong></p><p>　拉链法的缺点是：指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2022/05/13/02-shu-ju-jie-gou/er-cha-shu/"/>
    <url>/2022/05/13/02-shu-ju-jie-gou/er-cha-shu/</url>
    
    <content type="html"><![CDATA[<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="二叉树旋转"><a href="#二叉树旋转" class="headerlink" title="二叉树旋转"></a>二叉树旋转</h3><h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><ul><li>逆时针旋：头节点变成了心头节点的左孩子</li><li><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/%E5%B7%A6%E6%97%8B.gif" alt="img"></li></ul><h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><ul><li>顺时针旋：头节点变成了新头结点的右孩子。</li><li><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/%E5%8F%B3%E6%97%8B.gif" alt="img"></li></ul><h4 id="旋转的情况"><a href="#旋转的情况" class="headerlink" title="旋转的情况"></a>旋转的情况</h4><ul><li>LL<ul><li><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/LL.png" style="zoom:75%;" /></li><li></li></ul></li><li>RR<ul><li><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/RR.png" style="zoom:75%;" /></li></ul></li><li>LR<ul><li><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/LR.png" style="zoom:75%;" /></li></ul></li><li>RL<ul><li><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/RL.png" style="zoom:75%;" /></li></ul></li></ul><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><h4 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历(BFS)"></a>广度优先遍历(BFS)</h4><ul><li>广度优先遍历先从树的最高层开始，从左向右逐层向下访问树中的每一个元素。</li><li>应用：<ul><li>二叉树层序打印   力扣102</li><li>最短路径(<strong>无权最短路径问题</strong>)</li><li></li></ul></li></ul><h4 id="深度优先遍历-DFS）"><a href="#深度优先遍历-DFS）" class="headerlink" title="深度优先遍历(DFS）"></a>深度优先遍历(DFS）</h4><ul><li>深度优先遍历会尽量从根节点访问到叶节点，再回溯至最近一次有未访问子节点的节点，再访问到其叶节点。根据其访问节点的先后顺序可以有多种访问的方式，但常用的主要是<strong>前序树遍历、中序树遍历和后序树遍历</strong>。</li></ul><h5 id="前序树遍历"><a href="#前序树遍历" class="headerlink" title="前序树遍历"></a>前序树遍历</h5><ul><li>对于每一个子树的遍历顺序：中  左  右</li></ul><h5 id="中序树遍历"><a href="#中序树遍历" class="headerlink" title="中序树遍历"></a>中序树遍历</h5><ul><li>对于每一个子树的遍历顺序：左 中  右</li><li>后继节点 前驱节点  ：在中序遍历中一个节点的下一个或上一个</li><li>Morris遍历法：</li></ul><h5 id="后序树遍历"><a href="#后序树遍历" class="headerlink" title="后序树遍历"></a>后序树遍历</h5><ul><li>对于每一个子树的遍历顺序：右 左 中</li></ul><h4 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h4><ul><li>遍历标准：   当前节点为cur<ol><li>cur没有左子树，cue向右子树 移动(cur &#x3D; cur.right)</li><li>cur存在左子树，找到左子树上最右的节点 记为mostright</li><li>mostright的右子树为空， 则设置mostright的右子树指向cur,然后cur向左移动</li><li>mostright的右子树为cur,让其指向空，cur向右移动</li></ol></li><li>Morris遍历中， 如果一个节点有左子树，morris遍历能回到这个节点两次，当第二次到达这个节点的时候，说明左子树上的节点已经全部遍历完。如果一个节点没有左子树，则只到达这个节点一次。</li></ul><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><ul><li>满二叉树：一棵二叉树的结点要么是叶子结点，要么它有两个子结点（如果一个二叉树的层数为K，且结点总数是(2^k) -1，则它就是满二叉树。）</li><li>满二叉树的节点总数SUM和高度L的公式为   SUM &#x3D;  $2^{L}-1$</li></ul><h3 id="完全二叉树CBT"><a href="#完全二叉树CBT" class="headerlink" title="完全二叉树CBT"></a>完全二叉树CBT</h3><ul><li>若设二叉树的深度为k，除第 k 层外，其它各层 (1～k-1) 的结点数都达到最大个数，第k 层所有的结点都<strong>连续集中在最左边</strong>，这就是完全二叉树。</li></ul><h3 id="二叉查找树BST（搜索二叉树）"><a href="#二叉查找树BST（搜索二叉树）" class="headerlink" title="二叉查找树BST（搜索二叉树）"></a>二叉查找树BST（搜索二叉树）</h3><ul><li>首先它也是一个二叉树，故满足递归定义;</li><li>其次每个节点只存在一个值;</li><li>需满足左子树任意值&lt;&#x3D;根值&lt;&#x3D;右子树任意值 ，故按照中序遍历会得到一个非递减(依次升序)序列。标注的搜索二叉树没有重复的值，因为相同的值可以压缩在一个节点上。</li><li>性质<ul><li>1.在一棵二叉查找树上，执行查找、插入、删除等操作的时间复杂度为O（logn）。因为，一棵由n个结点，随机构造的二叉查找树的高度为lgn，所以顺理成章，一般操作的执行时间为O（lgn）。</li><li>2.但若是一棵具有n个结点的线性链，则此些操作最坏情况运行时间为O（n）。</li></ul></li></ul><h3 id="平衡二叉树AVL"><a href="#平衡二叉树AVL" class="headerlink" title="平衡二叉树AVL"></a>平衡二叉树AVL</h3><ul><li><p>首先仍是一棵二叉树，满足递归定义;</p></li><li><p>其次又是一棵BST，满足有序;</p></li><li><p>每个节点左右子树高度差的绝对值不能超过1</p></li><li><p>性质</p><ul><li>会发生左旋和右旋操作</li></ul></li></ul><h3 id="红黑树Red-Black-Tree"><a href="#红黑树Red-Black-Tree" class="headerlink" title="红黑树Red Black  Tree"></a>红黑树Red Black  Tree</h3><ul><li>首先仍是一棵二叉树，满足递归定义; </li><li>其次又是一棵BST，满足有序;</li><li>最长子树不超过最短子树的两倍</li><li>根节点是黑色，叶子节点为黑色。每个红色节点的子节点一定都是黑色。</li><li>任意一结点到每个叶子结点的路径都包含数量相同的黑结点。红色节点不相邻</li></ul><h3 id="SB树"><a href="#SB树" class="headerlink" title="SB树"></a>SB树</h3><ul><li>TODO</li></ul><h3 id="自适应树"><a href="#自适应树" class="headerlink" title="自适应树"></a>自适应树</h3><ul><li>虽然平衡树能使树的平均路径深度得到有效降低，但是频繁的对树进行平衡操作会造成很大的性能浪费，因为通常我们更关心执行插入、删除和查找操作的效率而不是树的形状。因为我们对不同元素的访问有偏好性，因此根据访问频率沿着树向上移动元素从而形成一种优先树即自适应树是一个很好的解决方案。</li><li>自适应树的构造策略分为：1）单一旋转：如果访问子节点，则将子节点围绕它的父节点进行旋转。2）移动到根部：重复子节点-父节点的旋转，直至将被访问元素移到根部。</li></ul><h5 id="张开策略"><a href="#张开策略" class="headerlink" title="张开策略"></a>张开策略</h5><h5 id="半长开策略"><a href="#半长开策略" class="headerlink" title="半长开策略"></a>半长开策略</h5><h3 id="treap树"><a href="#treap树" class="headerlink" title="treap树"></a>treap树</h3><ul><li>二叉查找树的操作非常高效，但多次操作时会发生树的不平衡现象，堆是完全平衡树，可以快速访问最大或者最小元素，但是不能立即访问其他元素。如果有一个树同时满足堆的部分性质和二叉查找树的部分性质的树称为他treap树。它有多种实现方式。</li></ul><h5 id="显示优先级实现-笛卡尔树"><a href="#显示优先级实现-笛卡尔树" class="headerlink" title="显示优先级实现-笛卡尔树"></a>显示优先级实现-笛卡尔树</h5><ul><li>对于它的每个节点包含一个键值对，其中键满足二叉树性质，值满足最大堆性质。<br>  在其中插入元素时，首先生成随机的优先级，用键根据二叉查找树性质在树中找到合适的位置插入，再根据值通过旋转二叉树方式来恢复堆属性。<br> 删除元素时将其优先级较高的节点围绕它进行旋转直至被删除的节点只有一个子节点后者没有子节点，此时直接将改元素删除。</li></ul><h5 id="隐式优先级实现"><a href="#隐式优先级实现" class="headerlink" title="隐式优先级实现"></a>隐式优先级实现</h5><ul><li><p>treap树并不总是需要在每个节点储存其优先级，第一种方法是使用一个散列函数h，将具有键值k的某项优先级设置为h（k），但这种方案暂不讨论。另外一种是通过数组分方式实现treap树，其中数组的序号代表其优先级，这种方式类似于最小堆。但是节点和子节点在数组中序号的对应方式不能套用堆中的公式。<br>  这种方案中插入一个节点，需要随机生成小于等于n的优先级i，如果i&#x3D;n，则直接将节点放在数组末尾，否则需要将数组中占据i位置的项通过一系列的旋转操作变为叶节点，再将需要插入的节点根据二叉树的性质放在合适的位置，再根据其优先级恢复整个的堆性质就能得到新的treap树。在数组中直接插入对应索引即得到新的数组。<br> 删除一个节点时，首先从treap树中删除节点，先通过二叉树删除节点规则将节点删除，然后在数组中将最后一个元素填到当前位置确定新的游优先级，再根据新的优先级恢复堆属性。</p></li><li></li></ul><h3 id="k-d树"><a href="#k-d树" class="headerlink" title="k-d树"></a>k-d树</h3><ul><li>通常二叉查找树的每个节点只有一个键值，当每个节点拥有多个键值时成为k-d树，k代表每个节点拥有的键值数。k-d树将各个维度在从根到子节点的每一层中有顺序的交替使用。通过这种方式可以在空间中划分很多不同的区域。</li></ul><h2 id="多叉树"><a href="#多叉树" class="headerlink" title="多叉树"></a>多叉树</h2><ul><li>二叉树中每个节点只有两个子节点，当每个节点最多包含m个节点时就是m阶多叉树</li><li>对于m阶的多差查找树有以下四个特性<ul><li>每个节点都可以包含m个子节点和m-1个键值。</li><li>所有节点的键值都按升序排列。</li><li>前i个子节点中的键值都小于第i个键值。</li><li>后m-i个子节点中的键值都大于第i个键值。</li></ul></li></ul><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><ul><li>m阶的B树具有以下性质：<ul><li>根节点至少有两个子节点</li><li>每个节点有M-1个key，并且以升序排列</li><li>位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间</li><li>其它节点至少有M&#x2F;2个子节点</li></ul></li></ul><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><ul><li><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/image-20201015000336247.png" alt="image-20201015000336247" style="zoom:80%;" /></li></ul><h3 id="DSW算法"><a href="#DSW算法" class="headerlink" title="DSW算法"></a>DSW算法</h3><ul><li>DSW算法构建平衡二叉树：TODO</li></ul><h3 id="Trie-前缀树字典树"><a href="#Trie-前缀树字典树" class="headerlink" title="Trie 前缀树字典树"></a>Trie 前缀树字典树</h3><ul><li><p><code>Trie树</code>又被称为前缀树、字典树，把单词字母一条一条灌进一棵树中，每个节点是<code>a-z</code>之间的字母，对于都是数字的字符串，字符集就是<code>0-9</code>， 每一个节点包含三个元素，分别是节点对应的<code>字符name</code>，存储的子节点信息<code>Map(name -&gt; 节点对象)</code>, 是否是 <code>词尾标志end</code>。 词尾标志可以记录到中间任一节点位置，词尾标志还能记录数量，为多少个字符串的结尾 </p></li><li><p><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/22206660-ae8616fb4bba1249.png" alt="img"></p></li><li><p><strong>字母应该放在边上，而不是节点上，放到节点上会增加实现难度</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大数据</title>
    <link href="/2022/05/13/02-shu-ju-jie-gou/da-shu-ju/"/>
    <url>/2022/05/13/02-shu-ju-jie-gou/da-shu-ju/</url>
    
    <content type="html"><![CDATA[<h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><h4 id="有一个包含20亿个全是32位整数的大文件，在其中找到出现次数最多的数，但是内存限制只有2G"><a href="#有一个包含20亿个全是32位整数的大文件，在其中找到出现次数最多的数，但是内存限制只有2G" class="headerlink" title="有一个包含20亿个全是32位整数的大文件，在其中找到出现次数最多的数，但是内存限制只有2G"></a>有一个包含20亿个全是32位整数的大文件，在其中找到出现次数最多的数，但是内存限制只有2G</h4><ul><li><p>使用哈希函数分流</p></li><li><p>分别使用hashMap进行统计，找到最多的数</p></li></ul><h4 id="32位无符号整数的范围是0-42亿，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围内必然有没有出现过的树，可以使用最多10M的内存，只用找到一个没出现过的数即可，该如何找？"><a href="#32位无符号整数的范围是0-42亿，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围内必然有没有出现过的树，可以使用最多10M的内存，只用找到一个没出现过的数即可，该如何找？" class="headerlink" title="32位无符号整数的范围是0-42亿，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围内必然有没有出现过的树，可以使用最多10M的内存，只用找到一个没出现过的数即可，该如何找？"></a>32位无符号整数的范围是0-42亿，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围内必然有没有出现过的树，可以使用最多10M的内存，只用找到一个没出现过的数即可，该如何找？</h4><ul><li>范围分成64个区间 </li><li>申请一个$2^{32}$  &#x2F; 64 的bitMap，大约占500M&#x2F;64  &#x3D;  8M空间</li><li>必然有填不满的区间，然后根据这个区间上缺的数遍历这个文件</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>根据内存限制决定区间的大小，根据区间大小，得到有多少个变量，来记录每个区间的数出现的次数</li><li>统计区间上的数的出现次数，找到不足的区间</li><li>利用bitMap对不满的区间，进行这个区间上的数的词频统计</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>其他常用算法</title>
    <link href="/2022/05/13/02-shu-ju-jie-gou/chang-yong-qi-ta-suan-fa/"/>
    <url>/2022/05/13/02-shu-ju-jie-gou/chang-yong-qi-ta-suan-fa/</url>
    
    <content type="html"><![CDATA[<h3 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h3><ul><li>Manacher算法，又叫“马拉车”算法，可以在时间**O(N)**的情况下求解一个字符串的最长回文子串长度的问题。</li><li>求解一个字符串的最长回文子串长度的问题另外一个写法,时间复杂度 O($n^2$)<ul><li>在每个字符串之间加入一个标志位，例如 11311 -&gt; #1#1#3#1#1#</li><li>然后每个索引上的值向左右遍历对比。</li><li>拿到最大的长度， 长度&#x2F;2  就是最长回文子串的长度</li></ul></li></ul><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>回文直径，回文半径</li><li>一个数组：每个索引上能建立的最大的回文半径</li><li>最大回文右边界  例如  012131210 最大回文边界为第二个0</li><li>最大回文有边界的中心</li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>在每个字符串之间加入一个标志位，例如 11311 -&gt; #1#1#3#1#1#</li></ul><ol start="2"><li><code>i</code>位置不再回文右边界里面，继续暴力求出在<code>i+1</code>的回文子串长度</li><li><code>i</code>位置在回文右边界内，根据回文中心<code>c</code>，做出i的对称点$i_2$<ol><li>$i_2$的回文直径在当前<code>c</code>的回文半径中，例如 z k [ a b($i_2$) a t f(<code>c</code>) t a b(<code>i</code>) a ] k u</li></ol><ul><li>此时<code>i</code>的回文半径和$i_2$一致</li></ul><ol start="2"><li>$i_2$的回文半径的索引超出了当前<code>c</code>的回文半径，例如a b [c d($i_2$) c b a t t(<code>c</code>) t a b c d(<code>i</code>) c] f<ul><li>此时<code>i</code>的回文半径为<code>i</code>到c的右边界的长度</li></ul></li><li>$i_2$的回文半径的索引等于了当前<code>c</code>的回文半径，例如 t [a b c($i_2$) b a k(<code>o</code>) a b c(<code>i</code>) b a] k<ul><li>此时<code>i</code>的回文半径无法确认，要从c的右边界的下一个继续校验</li></ul></li></ol></li></ol><h3 id="KMP字符串模式匹配算法"><a href="#KMP字符串模式匹配算法" class="headerlink" title="KMP字符串模式匹配算法"></a>KMP字符串模式匹配算法</h3><ul><li>主要解决包含的问题。例如：str1的子串集合中是否包含str2</li><li><strong>时间复杂度 O(n)</strong></li><li>思路</li></ul><h3 id="BFPRT算法-TOP-K"><a href="#BFPRT算法-TOP-K" class="headerlink" title="BFPRT算法(TOP-K)"></a>BFPRT算法(TOP-K)</h3><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li>用来求元素中第k大（或小）的值或是前k大（或小）的值     时间复杂度<strong>O(N)</strong></li></ul><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>快排的优化,优化了partition过程，在partition中根据所要找的数，只对左侧或者右侧进行递归partition</li><li>过程<ol><li>5个分一个组</li><li>将各个组排序</li><li>拿到每个数组的中位数组成一个新数组midArr </li><li>用midArr作为参数递归调用bfprt算法得到midArr的中位数</li><li>将该中位数作为partition的划分值来做partition,直到找到第K个大(小)的数</li></ol></li></ul><h3 id="窗口最大最小值的更新结构-单调双向队列"><a href="#窗口最大最小值的更新结构-单调双向队列" class="headerlink" title="窗口最大最小值的更新结构(单调双向队列)"></a>窗口最大最小值的更新结构(单调双向队列)</h3><ul><li>需要一个双端队列存储值和下标，队列的值从大到小排列</li><li>窗口中加数的逻辑<ul><li>加的数从<strong>队尾</strong>插入双端队列，并且要保证是从大到小的顺序，如果不符合先弹出双端队列中的值在塞入当前数及其索引</li><li>例如： 窗口中的数为 5 4 1 2 5 6    则此时双端队列中只有6</li></ul></li><li>窗口中减数的逻辑<ul><li>查看当前双端队列的头节点所存储的索引是否为当前要弹出的数的索引，如果是，则从双端队列弹出头节点</li></ul></li></ul><h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><ul><li>跳表实际上是一种增加了前向指针的链表，是一种随机化的数据结构，实质上是可以进行二分查找的有序链表；跳表在原来的有序链表上加上了多级索引，通过索引来快速查找；可以支持快速的删除、插入和查找操作。</li><li><img src="/../pic/%E8%B7%B3%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="img"></li></ul><h3 id="TrieTree"><a href="#TrieTree" class="headerlink" title="TrieTree"></a>TrieTree</h3><ul><li>字典前缀树</li></ul><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><ul><li>比特数组的容量m计算公式<ul><li>$m&#x3D; -\frac{NlnP}{ (ln2 )^ 2}$    bit</li><li>N为样本量，P:预期失误率   不是百分数</li></ul></li><li>比特数组中的插值数量(哈希函数的个数)k<ul><li>k &#x3D;  $ln2 * \frac{m}{n}$</li></ul></li><li>失误率P<ul><li>$P &#x3D; (1 - e^{-\frac{n*k}{m}})$</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2022/05/13/02-shu-ju-jie-gou/dp/"/>
    <url>/2022/05/13/02-shu-ju-jie-gou/dp/</url>
    
    <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul><li><p>动态规划和分治的区别：是否有子问题重复出现</p></li><li><p>动态规划和贪心的区别：</p><ul><li><p>关于最优子结构<br>贪心：每一步的最优解一定包含上一步的最优解，上一步之前的最优解无需记录<br>动态规划：全局最优解中一定包含某个局部最优解，但不一定包含上一步的局部最优解，因此需要记录之前的所有的局部最优解</p></li><li><p>关于子问题最优解组合成原问题最优解的组合方式<br>贪心：如果把所有的子问题看成一棵树的话，贪心从根出发，每次向下遍历最优子树即可，这里的最优是贪心意义上的最优。此时不需要知道一个节点的所有子树情况，于是构不成一棵完整的树<br>动态规划：动态规划需要对每一个子树求最优解，直至下面的每一个叶子的值，最后得到一棵完整的树，在所有子树都得到最优解后，将他们组合成答案</p></li><li><p>结果正确性<br>贪心不能保证求得的最后解是最佳的，复杂度低<br>动态规划本质是穷举法，可以保证结果是最佳的，复杂度高</p></li></ul></li></ul><table><thead><tr><th></th><th>分治</th><th>动态规划</th><th>贪心</th></tr></thead><tbody><tr><td>适用类型</td><td>通用</td><td>优化</td><td>优化</td></tr><tr><td>子问题</td><td>每个都不同</td><td>很多重复</td><td>只有一个</td></tr><tr><td>最优子结构</td><td>没有要求</td><td>必须满足</td><td>必须满足</td></tr><tr><td>子问题数</td><td>全部都要解</td><td>全部都要解</td><td>只解一个</td></tr></tbody></table><h4 id="什么样的递归可以修改为动态规划"><a href="#什么样的递归可以修改为动态规划" class="headerlink" title="什么样的递归可以修改为动态规划"></a>什么样的递归可以修改为动态规划</h4><ul><li>当一个递归过程中，有重复状态，并且状态与到达目标是没有关系的</li></ul><h3 id="线性动态规划"><a href="#线性动态规划" class="headerlink" title="线性动态规划"></a>线性动态规划</h3><ul><li><p>线性动态规划的主要特点是状态的推导是按照问题规模 i 从小到大依次推过去的，较大规模的问题的解依赖较小规模的问题的解。</p><p>这里问题规模为 i 的含义是考虑前 i 个元素 [0..i] 时问题的解。</p><p>状态定义：</p><p>dp[n] :&#x3D; [0..n] 上问题的解<br>状态转移：</p><p>dp[n] &#x3D; f(dp[n-1], …, dp[0])<br>从以上状态定义和状态转移可以看出，大规模问题的状态只与较小规模的问题有关，而问题规模完全用一个变量 i 表示，i 的大小表示了问题规模的大小，因此从小到大推 i 直至推到 n，就得到了大规模问题的解，这就是线性动态规划的过程。</p><p>按照问题的输入格式，线性动态规划解决的问题主要是单串，双串，矩阵上的问题，因为在单串，双串，矩阵上问题规模可以完全用位置表示，并且位置的大小就是问题规模的大小。因此从前往后推位置就相当于从小到大推问题规模。</p><p>线性动态规划是动态规划中最基本的一类。问题的形式、dp 状态和方程的设计、以及与其它算法的结合上面变化很多。按照 dp 方程中各个维度的含义，可以大致总结出几个主流的问题类型，见后面的小节。除此之外还有很多没有总结进来的变种问题，小众问题，和困难问题，这些问题的解法更多地需要结合自己的做题经验去积累，除此之外，常见的，主流的问题和解法都可以总结成下面的四个小类别。</p></li></ul><h2 id="左程云DP"><a href="#左程云DP" class="headerlink" title="左程云DP"></a>左程云DP</h2><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul><li>最优化原理，也就是最优子结构性质，这指的是一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优决策，简单来说就是一个最优化策略的子策略总是最优的，如果一个问题满足最优化原理就称其具有最优子结构性质</li><li>无后效性：指的是某状态下决策的收益，只与状态和决策相关，与到达该状态的方式无关</li><li>子问题的重叠性，动态规划将原来具有值数级时间复杂度的暴力搜索算法改进成了具有多项式时间复杂度的算法。其中的关键在于解决冗余，这就是动态规划算法的根本目的。</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>先做出暴力递归的方案</li><li>接下来分析哪些参数一旦固定，哪些值就可以固定，（哪些结果可以缓存来提高性能）</li><li>根据前面的参数做出表，</li><li>表中xy为调用递归的传入参数，</li><li>初始的传入参数就是在表中最后要求出的参数</li><li>已经可以得出的函数为递归中的终止条件</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul><li><p>【 题目】<br>给定数组arr， arr中所有的值都为正数且不重复。 每个值代表一种面值的货币， 每种面值的货币可以使用任意张， 再给定一<br>个整数aim代表要找的钱数， 求换钱有多少种方法。<br>【 举例】<br>arr&#x3D;[5,10,25,1]， aim&#x3D;0。<br>组成0元的方法有1种， 就是所有面值的货币都不用。 所以返回1。<br>arr&#x3D;[5,10,25,1]， aim&#x3D;15。<br>组成15元的方法有6种， 分别为3张5元、 1张10元+1张5元、 1张10元+5张1元、 10张1元+1张5元、 2张5元+5张1元和15张1元。 所以返回6。<br>arr&#x3D;[3,5]， aim&#x3D;2。任何方法都无法组成2元。 所以返回0</p></li><li><p>暴力递归代码</p><ul><li>&#96;&#96;&#96;java<br> &#x2F;**<br> * 暴力递归方法<br> *<br> * @param arr<br> * @param aim<br> * @return<br> <em>&#x2F;<br>public static int coins1(int[] arr, int aim) {<br>    if (arr &#x3D;&#x3D; null || arr.length &#x3D;&#x3D; 0 || aim &lt; 0) {<br>        return 0;<br>    }<br>    return process1(arr, 0, aim);<br>}<br><br>&#x2F;</em>*<br> * @param arr<br> * @param index 可以任意自由使用index及其之后所有的钱<br> * @param aim   目标钱数<br> * @return 方法数<br> *&#x2F;<br>public static int process1(int[] arr, int index, int aim) {<br>    int res &#x3D; 0;<br>    if (index &#x3D;&#x3D; arr.length) {<br>        res &#x3D; aim &#x3D;&#x3D; 0 ? 1 : 0;<br>    } else {<br>        for (int i &#x3D; 0; arr[index] * i &lt;&#x3D; aim; i++) {<br>            res +&#x3D; process1(arr, index + 1, aim - arr[index] * i);<br>        }<br>    }<br>    return res;<br>}<pre class="line-numbers language-none"><code class="language-none">+ 建立map二维数组，缓存以前的值+ 动态规划 ，表如图所示  ![image-20210405233450523](https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;X-Leonidas&#x2F;picRepository&#x2F;main&#x2F;img&#x2F;image-20210405233450523.png)  + index表示还剩下多少钱，aim为目标钱数  + 递归调用时，初始值为0，aim，故需要求出的值为X  + 递归终止条件为当index&#x3D;N时，aim&#x3D;&#x3D; 0 则为1 否则为0，为表中的已知数据  + 绿色为任意点的值，需要黄色的值来推出+ 代码如下:  + &#96;&#96;&#96;java    public static int coins3(int[] arr, int aim) &#123;            if (arr &#x3D;&#x3D; null || arr.length &#x3D;&#x3D; 0 || aim &lt; 0) &#123;                return 0;            &#125;            int[][] dp &#x3D; new int[arr.length][aim + 1];            &#x2F;&#x2F;第1列都为0.dp[i][0] 都为1，表示组成钱数0的方法只有1种            for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;                dp[i][0] &#x3D; 1;            &#125;            &#x2F;&#x2F;第1行中的某些项.dp[0][j]，只使用arr[0]货币，可以组成哪些数            for (int j &#x3D; 1; arr[0] * j &lt;&#x3D; aim; j++) &#123;                dp[0][arr[0] * j] &#x3D; 1;            &#125;            int num &#x3D; 0;            for (int i &#x3D; 1; i &lt; arr.length; i++) &#123;                for (int j &#x3D; 1; j &lt;&#x3D; aim; j++) &#123;                    num &#x3D; 0;                    for (int k &#x3D; 0; j - arr[i] * k &gt;&#x3D; 0; k++) &#123;                        num +&#x3D; dp[i - 1][j - arr[i] * k];                    &#125;                    dp[i][j] &#x3D; num;                &#125;            &#125;            return dp[arr.length - 1][aim];        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>推出dp[i][j] &#x3D; dp[i-1][j] + dp[i][j-arr[i]]</p><ul><li><pre><code class="java">public static int coins4(int[] arr, int aim) &#123;        if (arr == null || arr.length == 0 || aim &lt; 0) &#123;            return 0;        &#125;        int[][] dp = new int[arr.length][aim + 1];        for (int i = 0; i &lt; arr.length; i++) &#123;            dp[i][0] = 1;        &#125;        for (int j = 1; arr[0] * j &lt;= aim; j++) &#123;            dp[0][arr[0] * j] = 1;        &#125;        for (int i = 1; i &lt; arr.length; i++) &#123;            for (int j = 1; j &lt;= aim; j++) &#123;                dp[i][j] = dp[i - 1][j];                dp[i][j] += j - arr[i] &gt;= 0 ? dp[i][j - arr[i]] : 0;            &#125;        &#125;        return dp[arr.length - 1][aim];    &#125;</code></pre></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>栈</title>
    <link href="/2022/05/13/02-shu-ju-jie-gou/zhan-he-dui-lie/"/>
    <url>/2022/05/13/02-shu-ju-jie-gou/zhan-he-dui-lie/</url>
    
    <content type="html"><![CDATA[<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li>先进后出只能从栈顶访问和删除的数据结构，栈数据结构可以用于匹配分隔符以及大数相加的操作，可以用向量（数组）和链表的方式实现，其中链表的方式与抽象栈更匹配。在向量和链表形式的栈中，出栈操作的复杂度为O(1)，在向量栈中最坏的入栈复杂度为O(n)，而在链表栈中仍为O(1)。</li></ul><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><ul><li>单调递增栈：单调递增栈就是从栈底到栈顶数据是从大到小</li><li>单调递减栈：单调递减栈就是从栈底到栈顶数据是从小到大</li><li>数组值相等的时候，下标压在一起</li><li>一般解决一个数组中，离索引index两边最近的比它大的或小的值</li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li>一端用于新加元素，一端用于删除元素的数据结构。同样队列也可以使用数组和链表的方式实现。在双向链表的实现中，入队和出队的复杂度为O(1)，单向链表的出队操作复杂度为O(n)。</li></ul><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h4><ul><li>迷宫问题通常可以使用栈数据结构解决，将迷宫中的位置墙看做1，通道看做0，整个迷宫看做一个二维数组，从初始点开始，将上下左右可以通过的点坐标依次存入栈Stack，从栈顶取出一个位置作为当前位置，并按上述顺序继续搜索可以通过的点并存入栈中，当栈为空时则没有路径可以走出迷宫，当栈顶为出口时则找到正确路径</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>堆（优先队列）</title>
    <link href="/2022/05/13/02-shu-ju-jie-gou/you-xian-dui-lie-dui/"/>
    <url>/2022/05/13/02-shu-ju-jie-gou/you-xian-dui-lie-dui/</url>
    
    <content type="html"><![CDATA[<h3 id="优先队列-堆"><a href="#优先队列-堆" class="headerlink" title="优先队列(堆)"></a>优先队列(堆)</h3><ul><li>堆就是用数组实现的<strong>完全二叉树</strong></li><li>所以在堆中，在当前层级所有的节点都已经填满之前不允许开是下一层的填充，所以堆总是有这样的形状</li></ul><h4 id="堆和二叉搜索树的区别"><a href="#堆和二叉搜索树的区别" class="headerlink" title="堆和二叉搜索树的区别"></a>堆和二叉搜索树的区别</h4><ul><li><strong>节点的顺序。</strong>在二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。</li><li><strong>内存占用。</strong>普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左&#x2F;右子节点指针分配内存。堆仅仅使用一个数据来存储数组，且不使用指针。</li><li><strong>平衡。</strong>二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到<strong>O(log n)<strong>。你可以按任意顺序位置插入&#x2F;删除数据，或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足堆属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证</strong>O(log n)</strong> 的性能。</li><li><strong>搜索。</strong>在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。</li></ul><h4 id="用数组构建堆"><a href="#用数组构建堆" class="headerlink" title="用数组构建堆"></a>用数组构建堆</h4><ul><li>规律(N为当前节点的索引)<ul><li>头节点： $\frac {N-1}{2}$</li><li>节点高度为: $\log_2 N$</li><li>左子节点和右子节点： 2N+1  2N+2</li></ul></li><li>如果最下面的一层已经填满，那么那一层包含 <em>2^h</em> 个节点。树中这一层以上所有的节点数目为 <em>2^h - 1</em></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图</title>
    <link href="/2022/05/13/02-shu-ju-jie-gou/tu/"/>
    <url>/2022/05/13/02-shu-ju-jie-gou/tu/</url>
    
    <content type="html"><![CDATA[<ul><li>在计算机科学中，一个图就是一些<em>顶点</em>的集合，这些顶点通过一系列<em>边</em>结对（连接）。顶点用圆圈表示，边就是这些圆圈之间的连线。顶点之间通过边连接。</li><li>树和链表也属于图</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法概述</title>
    <link href="/2022/05/13/02-shu-ju-jie-gou/suan-fa/"/>
    <url>/2022/05/13/02-shu-ju-jie-gou/suan-fa/</url>
    
    <content type="html"><![CDATA[<h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h2><ul><li><p>算法的分类</p><ul><li><p><strong>决定性算法</strong>：对于给定的输入只有一种方式能确定下一步采取的操作，如求一个集合的合只需要逐个相加并不需要进行猜测。</p><p><strong>非决定性算法</strong>：非决定性算法将问题分解成猜测和验证两个阶段。算法的猜测阶段是非确定性的，算法的验证阶段是确定性的，它验证猜测阶段给出解的正确性。如查找算法会先猜测数组中某个数，再验证其是否是需要查找的那个数。</p></li></ul></li><li><p>需要解决的判定问题的分类</p><ul><li><strong>P问题</strong>：能够用决定性算法在多项式时间内解决的问题。</li><li><strong>NP问题</strong>：能够用非决定性算法在多项式时间内解决的问题。</li><li><strong>NPC问题</strong>：这里P类问题一定属于NP类问题。如果任何一个NP问题都能通过一个多项式时间算法转换为某个NP问题，那么这个NP问题就称为NP完全问题，该问题则成为<strong>NP完整性</strong>，也成为NPC问题。</li></ul></li><li><p>算法的复杂度</p><ul><li><strong>O表示法</strong> 表最小上界</li><li><strong>Ω表示法</strong> 表最大下界</li><li><strong>Θ表示法</strong> 当最小上界和最大下界相等时</li></ul></li></ul><h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><ul><li>先看是否有现成的工具类可以解决</li><li>主要判断边界条件</li><li>如何找到最优解<ul><li>从数据状况出发</li><li>从要求的时间复杂度出发</li></ul></li></ul><h3 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h3><ul><li><strong>1.有一个你想要测的方法a；</strong></li><li><strong>2.实现一个绝对正确但是复杂度不好的方法b；</strong></li><li><strong>3.实现一个随机样本产生器；</strong></li><li><strong>4.实现对比算法a和b的方法；</strong></li><li><strong>5.把方法a和方法b比对多次来验证方法a是否正确；</strong></li><li><strong>6.如果有一个样本使得比对出错，打印样本分析是哪个方法出错；</strong></li><li><strong>7.当样本数量很多时比对测试依然正确，可以确定方法a已经正确。</strong></li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li><p>Master公式<br>$$<br>T[N] &#x3D; aT[\frac{N}{b}]+O(N^d)<br>$$</p><ul><li>变量解释<ul><li>b:子过程的样本量</li><li>a:子过程的计算次数</li><li>O(N^d):子结果合并的时间复杂度</li></ul></li><li>当d&lt;$log_ba$时，时间复杂度为O($N^{log_b,a}$)</li><li>当d&#x3D;$log_ba$时，时间复杂度为O(($N^d$)*logN)</li><li>当d&gt;$log_ba$时，时间复杂度为O($N^d$)</li><li>如果a的x次方等于N（a&gt;0，且a≠1），那么数x叫做以a为底N的对数（logarithm），记作x&#x3D;log(a,N)</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>排序</title>
    <link href="/2022/05/13/02-shu-ju-jie-gou/pai-xu/"/>
    <url>/2022/05/13/02-shu-ju-jie-gou/pai-xu/</url>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h3 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h3><p>​排序算法比较基础，但是涉及到很多计算机科学的想法，如下：</p><p>​1、比较和非比较的策略</p><p>​2、迭代和递归的实现</p><p>​3、分而治之思想</p><p>​4、最佳、最差、平均情况时间复杂度分析</p><p>​5、随机算法</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><ul><li>假定待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，称这种排序算法是稳定的，否则称为不稳定的</li></ul><h3 id="2、排序算法的分类"><a href="#2、排序算法的分类" class="headerlink" title="2、排序算法的分类"></a>2、排序算法的分类</h3><h4 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h4><p><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/1.jpg" alt="1"></p><h4 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h4><p><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/2.jpg" alt="2"></p><h3 id="3、冒泡排序"><a href="#3、冒泡排序" class="headerlink" title="3、冒泡排序"></a>3、冒泡排序</h3><h4 id="（1）冒泡排序的介绍"><a href="#（1）冒泡排序的介绍" class="headerlink" title="（1）冒泡排序的介绍"></a>（1）冒泡排序的介绍</h4><p>​冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h4 id="（2）冒泡排序的原理："><a href="#（2）冒泡排序的原理：" class="headerlink" title="（2）冒泡排序的原理："></a>（2）冒泡排序的原理：</h4><p>​1、如果元素大小关系不正确，交换这两个数（在本例中为a&gt; b），</p><p>​2、比较一对相邻元素（a，b），</p><p>​3、重复步骤1和2，直到我们到达数组的末尾（最后一对是第（N-2）和（N-1）项，因为我们的数组从零开始）</p><p>​4、到目前为止，最大的元素将在最后的位置。 然后我们将N减少1，并重复步骤1，直到N &#x3D; 1。</p><h4 id="（3）动图演示"><a href="#（3）动图演示" class="headerlink" title="（3）动图演示"></a>（3）动图演示</h4><p><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/3.jpg" alt="3"></p><h4 id="（4）代码演示"><a href="#（4）代码演示" class="headerlink" title="（4）代码演示"></a>（4）代码演示</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    t <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    array<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、选择排序"><a href="#4、选择排序" class="headerlink" title="4、选择排序"></a>4、选择排序</h3><h4 id="（1）选择排序的介绍"><a href="#（1）选择排序的介绍" class="headerlink" title="（1）选择排序的介绍"></a>（1）选择排序的介绍</h4><p>​选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h4 id="（2）选择排序的原理"><a href="#（2）选择排序的原理" class="headerlink" title="（2）选择排序的原理"></a>（2）选择排序的原理</h4><p>​1、在 <strong>[L … N-1]</strong> 范围内找出最小项目 <strong>X</strong> 的位置，</p><p>​2、用第 <strong>L</strong> 项交换X，</p><p>​3、将下限 <strong>L</strong> 增加1并重复步骤1直到 <strong>L &#x3D; N-2</strong>。</p><h4 id="（3）动态图演示"><a href="#（3）动态图演示" class="headerlink" title="（3）动态图演示"></a>（3）动态图演示</h4><p><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/4.jpg" alt="4"></p><h4 id="（4）代码演示-1"><a href="#（4）代码演示-1" class="headerlink" title="（4）代码演示"></a>（4）代码演示</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>                     index <span class="token operator">=</span> j<span class="token punctuation">;</span>             <span class="token punctuation">&#125;</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5、插入排序"><a href="#5、插入排序" class="headerlink" title="5、插入排序"></a>5、插入排序</h3><h4 id="（1）插入排序的介绍"><a href="#（1）插入排序的介绍" class="headerlink" title="（1）插入排序的介绍"></a>（1）插入排序的介绍</h4><p>​插入排序（Insertion sort）是一种简单直观且稳定的排序算法。如果有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。</p><h4 id="（2）插入排序的原理"><a href="#（2）插入排序的原理" class="headerlink" title="（2）插入排序的原理"></a>（2）插入排序的原理</h4><p>​1、从第一个元素开始，该元素可以认为已经被排序；</p><p>​2、取出下一个元素，在已经排序的元素序列中从后向前扫描；</p><p>​3、如果该元素（已排序）大于新元素，将该元素移到下一位置；</p><p>​4、重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</p><p>​5、将新元素插入到该位置后；</p><p>​6、重复步骤2~5。</p><h4 id="（3）动态图演示-1"><a href="#（3）动态图演示-1" class="headerlink" title="（3）动态图演示"></a>（3）动态图演示</h4><p><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/5.jpg" alt="img"></p><h4 id="（4）代码演示-2"><a href="#（4）代码演示-2" class="headerlink" title="（4）代码演示"></a>（4）代码演示</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> current<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            current <span class="token operator">=</span> array<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> preIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>preIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> current <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                array<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>                preIndex<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            array<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> current<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6、归并排序"><a href="#6、归并排序" class="headerlink" title="6、归并排序"></a>6、归并排序</h3><h4 id="（1）归并排序的介绍"><a href="#（1）归并排序的介绍" class="headerlink" title="（1）归并排序的介绍"></a>（1）归并排序的介绍</h4><p>​归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><h4 id="（2）归并排序的原理"><a href="#（2）归并排序的原理" class="headerlink" title="（2）归并排序的原理"></a>（2）归并排序的原理</h4><p>​1、将每对单个元素（默认情况下，已排序）归并为2个元素的有序数组，</p><p>​2、将2个元素的每对有序数组归并成4个元素的有序数组，重复这个过程……，</p><p>​3、最后一步：归并2个N &#x2F; 2元素的排序数组（为了简化讨论，我们假设N是偶数）以获得完全排序的N个元素数组。</p><h4 id="（3）动态图演示-2"><a href="#（3）动态图演示-2" class="headerlink" title="（3）动态图演示"></a>（3）动态图演示</h4><p><img src="/..%5Cpic%5C6.jpg" alt="img"></p><h4 id="（4）代码演示-3"><a href="#（4）代码演示-3" class="headerlink" title="（4）代码演示"></a>（4）代码演示</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">MergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> array<span class="token punctuation">;</span>       <span class="token keyword">int</span> mid <span class="token operator">=</span> array<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>       <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> left <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> right <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> array<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token class-name">MergeSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">MergeSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>left<span class="token punctuation">.</span>length <span class="token operator">+</span> right<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> result<span class="token punctuation">.</span>length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> left<span class="token punctuation">.</span>length<span class="token punctuation">)</span>               result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> right<span class="token punctuation">.</span>length<span class="token punctuation">)</span>               result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> right<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>               result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token keyword">else</span>               result<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token keyword">return</span> result<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7、快速排序"><a href="#7、快速排序" class="headerlink" title="7、快速排序"></a>7、快速排序</h3><h4 id="（1）快速排序的介绍"><a href="#（1）快速排序的介绍" class="headerlink" title="（1）快速排序的介绍"></a>（1）快速排序的介绍</h4><p>​快速排序（Quicksort）是对冒泡排序的一种改进。</p><p>​它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><h4 id="（2）快速排序的原理"><a href="#（2）快速排序的原理" class="headerlink" title="（2）快速排序的原理"></a>（2）快速排序的原理</h4><p>​1、从数列中挑出一个元素，称为 “基准”（pivot）；<br>​2、重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>​3、递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><h4 id="（3）动态图演示-3"><a href="#（3）动态图演示-3" class="headerlink" title="（3）动态图演示"></a>（3）动态图演示</h4><p><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/7.jpg" alt="img"></p><h4 id="（4）代码演示-4"><a href="#（4）代码演示-4" class="headerlink" title="（4）代码演示"></a>（4）代码演示</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**     * 快速排序方法     * @param array     * @param start     * @param end     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> start <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> end <span class="token operator">>=</span> array<span class="token punctuation">.</span>length <span class="token operator">||</span> start <span class="token operator">></span> end<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> smallIndex <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>smallIndex <span class="token operator">></span> start<span class="token punctuation">)</span>            <span class="token class-name">QuickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> start<span class="token punctuation">,</span> smallIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>smallIndex <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>            <span class="token class-name">QuickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> smallIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 快速排序算法——partition     * @param array     * @param start     * @param end     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> pivot <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>start <span class="token operator">+</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> smallIndex <span class="token operator">=</span> start <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> pivot<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> start<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> array<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                smallIndex<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> smallIndex<span class="token punctuation">)</span>                    <span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> i<span class="token punctuation">,</span> smallIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> smallIndex<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 交换数组内两个元素     * @param array     * @param i     * @param j     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8、希尔排序"><a href="#8、希尔排序" class="headerlink" title="8、希尔排序"></a>8、希尔排序</h3><h4 id="（1）希尔排序的介绍"><a href="#（1）希尔排序的介绍" class="headerlink" title="（1）希尔排序的介绍"></a>（1）希尔排序的介绍</h4><p>​希尔排序(Shell’s Sort)是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因D.L.Shell于1959年提出而得名。</p><p>​希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><h4 id="（2）希尔排序的原理"><a href="#（2）希尔排序的原理" class="headerlink" title="（2）希尔排序的原理"></a>（2）希尔排序的原理</h4><p>​1、选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；<br>​2、按增量序列个数k，对序列进行k 趟排序；<br>​3、每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p><h4 id="（3）动态图演示-4"><a href="#（3）动态图演示-4" class="headerlink" title="（3）动态图演示"></a>（3）动态图演示</h4><p><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/8.jpg" alt="img"></p><h4 id="（4）代码演示-5"><a href="#（4）代码演示-5" class="headerlink" title="（4）代码演示"></a>（4）代码演示</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**    * 希尔排序    *    * @param array    * @return    */</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">ShellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">int</span> len <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>       <span class="token keyword">int</span> temp<span class="token punctuation">,</span> gap <span class="token operator">=</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>       <span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>               temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>               <span class="token keyword">int</span> preIndex <span class="token operator">=</span> i <span class="token operator">-</span> gap<span class="token punctuation">;</span>               <span class="token keyword">while</span> <span class="token punctuation">(</span>preIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                   array<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>                   preIndex <span class="token operator">-=</span> gap<span class="token punctuation">;</span>               <span class="token punctuation">&#125;</span>               array<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span>           gap <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token keyword">return</span> array<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9、计数排序"><a href="#9、计数排序" class="headerlink" title="9、计数排序"></a>9、计数排序</h3><h4 id="（1）计数排序的介绍"><a href="#（1）计数排序的介绍" class="headerlink" title="（1）计数排序的介绍"></a>（1）计数排序的介绍</h4><p>​计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<br>​计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p><h4 id="（2）计数排序的原理"><a href="#（2）计数排序的原理" class="headerlink" title="（2）计数排序的原理"></a>（2）计数排序的原理</h4><p>​1、找出待排序的数组中最大和最小的元素；<br>​2、统计数组中每个值为i的元素出现的次数，存入数组C的第i项；<br>​3、对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；<br>​4、反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</p><h4 id="（3）动态图演示-5"><a href="#（3）动态图演示-5" class="headerlink" title="（3）动态图演示"></a>（3）动态图演示</h4><p><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%20.jpg" alt="img"></p><h4 id="（4）代码演示-6"><a href="#（4）代码演示-6" class="headerlink" title="（4）代码演示"></a>（4）代码演示</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**    * 计数排序    *    * @param array    * @return    */</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">CountingSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> array<span class="token punctuation">;</span>       <span class="token keyword">int</span> bias<span class="token punctuation">,</span> min <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> max <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> max<span class="token punctuation">)</span>               max <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span>               min <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       bias <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">-</span> min<span class="token punctuation">;</span>       <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>max <span class="token operator">-</span> min <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>bucket<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           bucket<span class="token punctuation">[</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> bias<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>               array<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">-</span> bias<span class="token punctuation">;</span>               bucket<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>               index<span class="token operator">++</span><span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span> <span class="token keyword">else</span>               i<span class="token operator">++</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token keyword">return</span> array<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10、桶排序"><a href="#10、桶排序" class="headerlink" title="10、桶排序"></a>10、桶排序</h3><h4 id="（1）桶排序的介绍"><a href="#（1）桶排序的介绍" class="headerlink" title="（1）桶排序的介绍"></a>（1）桶排序的介绍</h4><p>​桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。</p><h4 id="（2）桶排序的原理"><a href="#（2）桶排序的原理" class="headerlink" title="（2）桶排序的原理"></a>（2）桶排序的原理</h4><p>​1、设置一个定量的数组当作空桶；<br>​2、遍历输入数据，并且把数据一个一个放到对应的桶里去；<br>​3、对每个不是空的桶进行排序；<br>​4、从不是空的桶里把排好序的数据拼接起来。 </p><h4 id="（3）动态图演示-6"><a href="#（3）动态图演示-6" class="headerlink" title="（3）动态图演示"></a>（3）动态图演示</h4><p><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/10.jpg"></p><h4 id="（4）代码演示-7"><a href="#（4）代码演示-7" class="headerlink" title="（4）代码演示"></a>（4）代码演示</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**    * 桶排序    *     * @param array    * @param bucketSize    * @return    */</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> <span class="token class-name">BucketSort</span><span class="token punctuation">(</span><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>array <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> array<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span>           <span class="token keyword">return</span> array<span class="token punctuation">;</span>       <span class="token keyword">int</span> max <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> min <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 找到最大值最小值</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">></span> max<span class="token punctuation">)</span>               max <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">&lt;</span> min<span class="token punctuation">)</span>               min <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token keyword">int</span> bucketCount <span class="token operator">=</span> <span class="token punctuation">(</span>max <span class="token operator">-</span> min<span class="token punctuation">)</span> <span class="token operator">/</span> bucketSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>       <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> bucketArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>bucketCount<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> resultArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucketCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           bucketArr<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           bucketArr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> min<span class="token punctuation">)</span> <span class="token operator">/</span> bucketSize<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucketCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span>bucketSize <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果带排序数组中有重复数字时  感谢 @见风任然是风 朋友指出错误</span>               <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> bucketArr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>                   resultArr<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>bucketArr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span>bucketCount <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>                   bucketSize<span class="token operator">--</span><span class="token punctuation">;</span>               <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> temp <span class="token operator">=</span> <span class="token class-name">BucketSort</span><span class="token punctuation">(</span>bucketArr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> bucketSize<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> temp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>                   resultArr<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span>       <span class="token punctuation">&#125;</span>       <span class="token keyword">return</span> resultArr<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11、基数排序"><a href="#11、基数排序" class="headerlink" title="11、基数排序"></a>11、基数排序</h3><h4 id="（1）基数排序的介绍"><a href="#（1）基数排序的介绍" class="headerlink" title="（1）基数排序的介绍"></a>（1）基数排序的介绍</h4><p>​基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；<br>​基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的</p><h4 id="（2）基数排序的原理"><a href="#（2）基数排序的原理" class="headerlink" title="（2）基数排序的原理"></a>（2）基数排序的原理</h4><p>​1、取得数组中的最大数，并取得位数；<br>​2、arr为原始数组，从最低位开始取每个位组成radix数组；<br>​3、对radix进行计数排序（利用计数排序适用于小范围数的特点）；</p><h4 id="（3）动态图演示-7"><a href="#（3）动态图演示-7" class="headerlink" title="（3）动态图演示"></a>（3）动态图演示</h4><p><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/11.jpg" alt="img"></p><h4 id="（4）代码演示-8"><a href="#（4）代码演示-8" class="headerlink" title="（4）代码演示"></a>（4）代码演示</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**    * 基数排序    * @param array    * @return    */</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">RadixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>array <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> array<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span>           <span class="token keyword">return</span> array<span class="token punctuation">;</span>       <span class="token comment">// 1.先算出最大数的位数；</span>       <span class="token keyword">int</span> max <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           max <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token keyword">int</span> maxDigit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">while</span> <span class="token punctuation">(</span>max <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           max <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>           maxDigit<span class="token operator">++</span><span class="token punctuation">;</span>       <span class="token punctuation">&#125;</span>       <span class="token keyword">int</span> mod <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> div <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>       <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span> bucketList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ArrayList</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>           bucketList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxDigit<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> mod <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">,</span> div <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>           <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>               <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">%</span> mod<span class="token punctuation">)</span> <span class="token operator">/</span> div<span class="token punctuation">;</span>               bucketList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span>           <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>           <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> bucketList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>               <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> bucketList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>                   array<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> bucketList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>               bucketList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">&#125;</span>       <span class="token punctuation">&#125;</span>       <span class="token keyword">return</span> array<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="12、堆排序"><a href="#12、堆排序" class="headerlink" title="12、堆排序"></a>12、堆排序</h3><h4 id="（1）堆排序的介绍"><a href="#（1）堆排序的介绍" class="headerlink" title="（1）堆排序的介绍"></a>（1）堆排序的介绍</h4><p>​堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h4 id="（2）堆排序的原理"><a href="#（2）堆排序的原理" class="headerlink" title="（2）堆排序的原理"></a>（2）堆排序的原理</h4><p>​1、将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；<br>​2、将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；<br>​3、由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</p><h4 id="（3）动态图演示-8"><a href="#（3）动态图演示-8" class="headerlink" title="（3）动态图演示"></a>（3）动态图演示</h4><p><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/12.jpg" alt="img"></p><h4 id="（4）代码演示-9"><a href="#（4）代码演示-9" class="headerlink" title="（4）代码演示"></a>（4）代码演示</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//声明全局变量，用于记录数组array的长度；</span><span class="token keyword">static</span> <span class="token keyword">int</span> len<span class="token punctuation">;</span>    <span class="token comment">/**     * 堆排序算法     *     * @param array     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token class-name">HeapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        len <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> array<span class="token punctuation">;</span>        <span class="token comment">//1.构建一个最大堆</span>        <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>len <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            len<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> array<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 建立最大堆     *     * @param array     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//从最后一个非叶子节点开始向上构造最大堆</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>len<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//感谢 @让我发会呆 网友的提醒，此处应该为 i = (len/2 - 1) </span>            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/**     * 调整使之成为最大堆     *     * @param array     * @param i     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">adjustHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> maxIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token comment">//如果有左子树，且左子树大于父节点，则将最大指针指向左子树</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">></span> array<span class="token punctuation">[</span>maxIndex<span class="token punctuation">]</span><span class="token punctuation">)</span>            maxIndex <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token comment">//如果有右子树，且右子树大于父节点，则将最大指针指向右子树</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> array<span class="token punctuation">[</span>maxIndex<span class="token punctuation">]</span><span class="token punctuation">)</span>            maxIndex <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">//如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>maxIndex <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> maxIndex<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">adjustHeap</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> maxIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="13、外部排序"><a href="#13、外部排序" class="headerlink" title="13、外部排序"></a>13、外部排序</h3><ul><li>外部排序是指待排序记录的数量很大，以致内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。</li></ul><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul><li>按照内存大小，将大文件分成若干长度为 l 的子文件（l 应小于内存的可使用容量），然后将各个子文件依次读入内存，使用适当的内部排序算法对其进行排序（排好序的子文件统称为“归并段”或者“顺段”），将排好序的归并段重新写入外存，为下一个子文件排序腾出内存空间；</li><li>对得到的顺段进行合并，直至得到整个有序的文件为止。</li></ul><h4 id="时间分析"><a href="#时间分析" class="headerlink" title="时间分析"></a>时间分析</h4><ul><li>外部排序所需总的时间 &#x3D; <strong>内部排序（产生初始归并段）所需的时间（m×tIS）</strong>+<strong>外存信息读写的时间（d×tIO）</strong>+<strong>内部归并所需的时间（s×utmg）</strong><ul><li>tIS:得到一个初始归并段进行内部排序所需时间的均值<br> m:经过内部排序之后得到的初始归并段的个数<br> tIO:进行一次外存读&#x2F;写时间的均值<br> d:总的读&#x2F;写次数<br> utmg:对u个记录进行内部归并排序所需时间<br> s:为归并的趟数</li></ul></li></ul><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><ul><li>给你一个包含20亿个int类型整数的文件，计算机的内存只有2GB，怎么给它们排序？<ul><li>把8GB分割成4个2GB的数据来排，然后在把他们拼凑回去</li><li>内部排序的时候可以使用<strong>快速排序</strong>或<strong>归并排序</strong>等算法</li><li>把两个2G的有序子串合并成一个大的有序子串</li><li>总共经过三次合并之后就可以得到8G的有序子串。</li></ul></li></ul><h4 id="多路归并排序"><a href="#多路归并排序" class="headerlink" title="多路归并排序"></a>多路归并排序</h4><ul><li><p>基于上述算法的改进，由两两合并改为四个有序子串一起合并,4个有序子串的合并，叫4路归并。如果是n个有序子串的合并，就把它称为n路归并。n并非越大越好。</p></li><li></li></ul><h5 id="败者树和胜者树"><a href="#败者树和胜者树" class="headerlink" title="败者树和胜者树"></a>败者树和胜者树</h5><ul><li><p>败者树是树形选择排序的一种变形，本身是一棵完全二叉树</p></li><li><p>胜者树是树中每个非终端结点（除叶子结点之外的其它结点）中的值都表示的是左右孩子相比较后的较小值（谁最小即为胜者），而败者树则相反</p></li><li><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%E8%83%9C%E8%80%85%E6%A0%91.png" alt="外部排序胜者树" style="zoom:67%;" /></li><li><p><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%E8%B4%A5%E8%80%85%E6%A0%91.png" alt="外部排序败者树"></p></li><li><p>为一棵 5-路归并的败者树，其中 b0—b4 为树的叶子结点，分别为 5 个归并段中存储的记录的关键字。 ls 为一维数组，表示的是非终端结点，其中存储的数值表示第几归并段（例如 b0 为第 0 个归并段）。ls[0] 中存储的为最终的胜者，表示当前第 3 归并段中的关键字最小。</p><p>当最终胜者判断完成后，只需要更新叶子结点 b3 的值，即导入关键字 15，然后让该结点不断同其双亲结点所表示的关键字进行比较，败者留在双亲结点中，胜者继续向上比较。</p></li></ul><h4 id="置换选择"><a href="#置换选择" class="headerlink" title="置换选择"></a>置换选择</h4><ul><li>实例：例如已知初始文件中总共有 24 个记录，假设内存工作区最多可容纳 6 个记录，按照之前的选择排序算法最少也只能分为 4 个初始归并段。而如果使用置换—选择排序，可以实现将 24 个记录分为 3 个初始归并段，如图 1 所示：</li><li><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F%E7%BD%AE%E6%8D%A2%E9%80%89%E6%8B%A9.png" alt="外部排序置换选择"></li></ul><h5 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h5><ol><li>首先从初始文件中输入 6 个记录到内存工作区中；</li><li>从内存工作区中选出关键字最小的记录，将其记为 MINIMAX 记录；</li><li>然后将 MINIMAX 记录输出到归并段文件中；</li><li>此时内存工作区中还剩余 5 个记录，若初始文件不为空，则从初始文件中输入下一个记录到内存工作区中；</li><li>从内存工作区中的所有值中选出<strong>比 MINIMAX 值大的记录但是内存中尽量小的</strong>的记录，作为新的 MINIMAX 记录；</li><li>重复过程 3—5，直至在内存工作区中选不出新的 MINIMAX 记录为止，由此就得到了一个初始归并段；</li><li>重复 2—6，直至内存工作为空，由此就可以得到全部的初始归并段。</li></ol><h4 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h4><ul><li>TODO</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2022/05/13/02-shu-ju-jie-gou/lian-biao/"/>
    <url>/2022/05/13/02-shu-ju-jie-gou/lian-biao/</url>
    
    <content type="html"><![CDATA[<h3 id="链表的分类"><a href="#链表的分类" class="headerlink" title="链表的分类"></a>链表的分类</h3><h4 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h4><p>+ </p><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>+ </p><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p>+ </p><h4 id="跳跃链表"><a href="#跳跃链表" class="headerlink" title="跳跃链表"></a>跳跃链表</h4><ul><li>根据节点数量将链表分为多级，每个节点包含自身级数的指针数组，其中的元素分别指向同级的下一个节点。从最低的0级到最高级分别可以形成一个独立的子链</li><li>跳跃链表一定是有序的，通常使用Root数组保存每一级的根节点，每一级子链中的元素都存在于其下一级的子链中，其中0级节点包含所有的元素。链表的级数maxLevel于链表节点数n之间的关系为<code>maxLevel = [lg 2 n] + 1</code>。为了避免在插入和删除节点的时候重新够着链表，放弃对不同级上节点的位置要求，仅保留不同级上的节点数目要求，这样的链表又称为<strong>随机跳跃链表</strong>。通过<code>choosePowers()</code>函数生成powers数组，然后通过<code>chooseLeves()</code>函数确定当前插入节点的级数。</li></ul><h4 id="稀疏表"><a href="#稀疏表" class="headerlink" title="稀疏表"></a>稀疏表</h4><ul><li>当一个表只有一小部分空间被使用的时候成为稀疏表。其中很多稀疏表都可以使用链表的数据结构方式解决。例如当储存一个学校所有学生成绩时。如果用二维数组，课程作为行，学生作为列，这时很多学生并不会选修所有的课，这会造成大量的空间浪费。此时，使用Class和Student两个数组，其中class数组每个元素记录选修这门课程的链表，Student中每个元素记录这个学生所修课程的链表，这样会大量节约所需的内存空间。<br>  数组的优点是随机访问，因此需要直接访问某个元素，数组是更好的选中，如二分查找法和大多数排序算法。当只需要固定的访问某些元素（如第一个和最后一个），并且结构的改变是算法的核心则链表是更好的选则，如队列。另外数组的另一个优点是空间，链表本身还会花空间存储指向节点的指针。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构及算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统基础知识</title>
    <link href="/2022/05/08/01-cao-zuo-xi-tong/cao-zuo-xi-tong-ji-chu-zhi-shi/"/>
    <url>/2022/05/08/01-cao-zuo-xi-tong/cao-zuo-xi-tong-ji-chu-zhi-shi/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><ul><li><p><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/%E5%86%AF%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84.png" alt="img"></p><p>冯诺依曼结构</p></li><li><p>VFS</p><ul><li>虚拟文件系统，目录树</li></ul></li><li><p>inode</p><ul><li>文件索引</li></ul></li><li><p>pageCache(页缓存)</p></li><li><p>FD文件描述符</p></li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li><strong>并行和并发</strong><ul><li>基本概念<br>并发：宏观上在一段时间内能同时运行多个程序<br> 并行：同一时刻能运行多个指令<br>  区别两者的关键：是否同时</li><li>并行需要硬件支持，多l流水线、分布式计算机，在计算机上的体现就是增加cpu的数量可以提高并行</li><li>操作系统引入进程和线程，使得程序可以并发运行</li></ul></li><li><strong>共享</strong><ul><li>共享是指系统中的资源可以被多个并发进程使用</li><li>有两种共享方式：互斥共享和同时共享</li><li>互斥共享的资源为临界资源，例如打印机，在同一时间只允许一个进程访问，需要用同步机制来实现对临界资源的访问</li></ul></li><li><strong>虚拟</strong><ul><li>虚拟技术把一个物理实体转换为多个逻辑实体</li><li>主要的虚拟技术：<ul><li>时分复用技术<em>time-multiplexed sharing</em></li><li>空分复用技术<em>space-multiplexed sharing</em></li></ul></li><li>时分复用技术是在“时间”上将资源分割成更小的单位供不同的进程使用，多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占有处理器，每次只执行一小个时间片并快速切换。</li><li>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</li></ul></li><li><strong>异步</strong><ul><li>异步是彼此独立， 在等待某事件的过程中去做另一件事情</li><li>异步是目的，多线程只是实现异步的一种手段，所以异步和多线程并不相同</li></ul></li></ol><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><ol><li>进程管理<br>进程控制，进程同步，进程通信，死锁处理，处理调度</li><li>内存管理<ul><li>内存分配、地址映射、内存保护和共享、虚拟内存</li></ul></li><li>文件管理<ul><li>文件存储空间的管理、目录管理、文件读写管理和保护</li></ul></li><li>设备管理<ul><li>完成用户的I&#x2F;O请求，方便用户使用各种设备，并提高设备的利用率</li><li>主要包括缓冲管理、设备分配、设备处理、虚拟设备等</li></ul></li></ol><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><ol><li><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p></li><li><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.png" style="zoom:60%;" /><h3 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h3><ul><li>内核态（<em>Kernel Mode</em>）：CPU可以访问内存所有数据, 包括外围设备, 例如硬盘, 网卡. CPU也可以将自己从一个程序切换到另一个程序</li><li>用户态 (<em>User Mode</em>) : 只能受限的访问内存, 且不允许访问外围设备. 占用CPU的能力被剥夺, CPU资源可以被其他程序获取</li></ul><h3 id="为什么有内核态和用户态？"><a href="#为什么有内核态和用户态？" class="headerlink" title="为什么有内核态和用户态？"></a>为什么有内核态和用户态？</h3><ul><li>由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 – 用户态 和 内核态</li></ul><h3 id="系统调用-内核切换"><a href="#系统调用-内核切换" class="headerlink" title="系统调用,内核切换"></a>系统调用,内核切换</h3><ul><li>内核切换在CPU中的实现称之为陷阱指令(Trap Instruction)</li><li>内核调用：操作系统（内核）相当于是在应用程序和硬件之间添加了一个中间层。所以应用程序是不能够直接访问硬件设备的，只能使用内核向外提供的一组接口，这些接口让应用程序受限地访问硬件设备。我们把调用这些接口的过程叫做系统调用</li><li>工作流程<ol><li>用户态程序将一些数据值放在寄存器中, 或者使用参数创建一个堆栈(stack frame), 以此表明需要操作系统提供的服务.</li><li>用户态程序执行陷阱指令</li><li>CPU切换到内核态, 并跳到位于内存指定位置的指令, 这些指令是操作系统的一部分, 他们具有内存保护, 不可被用户态程序访问</li><li>这些指令称之为陷阱(trap)或者系统调用处理器(system call handler). 他们会读取程序放入内存的数据参数, 并执行程序请求的服务</li><li>系统调用完成后, 操作系统会重置CPU为用户态并返回系统调用的结果</li></ol></li></ul><h3 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h3><ul><li>外中断<br>由 CPU 执行指令以外的事件引起，如 I&#x2F;O 完成中断，表示设备输入&#x2F;输出处理已经完成，处理器能够发送下一个输入&#x2F;输出请求。此外还有时钟中断、控制台中断等。</li><li>异常<br>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</li><li>陷入<br>在用户程序中使用系统调用。</li></ul></li></ol><h2 id="大内核和微内核"><a href="#大内核和微内核" class="headerlink" title="大内核和微内核"></a>大内核和微内核</h2><ol><li>大内核<br>大内核系统将操作系统的主要内容模块都作为一个紧密联系的整体运行在核心态，从而为应用提供高性能的系统服务。因为各管理模块之间共享信息，能有效 利用相互之间的有效特性， 所以具有无可比拟的性能优势。</li><li>微内核<br>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</li></ol><h2 id="中断分类-1"><a href="#中断分类-1" class="headerlink" title="中断分类"></a>中断分类</h2><ol><li>外中断<br>由 CPU 执行指令以外的事件引起，如 I&#x2F;O 完成中断，表示设备输入&#x2F;输出处理已经完成，处理器能够发送下一个输入&#x2F;输出请求。此外还有时钟中断、控制台中断等</li><li>异常<br>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等</li><li>陷入<br>在用户程序中使用系统调用。</li></ol><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程、线程和协程"><a href="#进程、线程和协程" class="headerlink" title="进程、线程和协程"></a>进程、线程和协程</h2><ul><li>进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元</li></ul><h3 id="1-进程"><a href="#1-进程" class="headerlink" title="1.进程"></a>1.进程</h3><ul><li>进程是资源分配的基本单位</li><li>进程控制块(Process Control Block,PCB)描述进程的基本信息和运行状态,所谓的创建进程和撤销进程,都是指对PCB的操作</li><li>进程可以并发执行</li></ul><h4 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h4><ul><li>僵尸进程<ul><li>父进程产生子进程后，会维护子进程的一个PCB结构，子进程退出，由父进程释放，如果如进程没有释放，那么子进程成为一个僵尸进程</li></ul></li><li>孤儿进程<ul><li>子进程结束前，父进程已经退出。</li><li>孤儿进程会成为iinit进程的孩子，由1号进程维护。</li></ul></li></ul><h3 id="2-线程"><a href="#2-线程" class="headerlink" title="2.线程"></a>2.线程</h3><ul><li>线程是独立调度的基本单位</li><li>一个进程可以有多个线程,他们共享线程资源</li></ul><h3 id="3-纤程-协程-Fiber"><a href="#3-纤程-协程-Fiber" class="headerlink" title="3.纤程(协程)Fiber"></a>3.纤程(协程)Fiber</h3><ul><li><p>协程运行在线程之上，当一个协程执行完成后，可以选择主动让出，让另一个协程运行在当前线程之上。<strong>协程并没有增加线程数量，只是在线程的基础之上通过分时复用的方式运行多个协程</strong>，而且协程的切换在用户态完成，切换的代价比线程从用户态到内核态的代价小很多。</p></li><li><p>在协程中尽量不要调用阻塞IO的方法，比如打印，读取文件，Socket接口等，除非改为异步调用的方式，并且协程只有在IO密集型的任务中才会发挥作用。<strong>协程只有和异步IO结合起来才能发挥出最大的威力</strong></p></li><li><p>JAVA支持纤程的类库：quasar_core,GO、python支持</p></li></ul><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ul><li>资源<br><strong>进程是资源分配的基本单位</strong>,线程不拥有资源,线程访问隶属进程的资源</li><li>调度<br><strong>线程是独立调度的基本单位</strong>,在同一个进程中,线程的切换不会引起进程的切换,但一个进程中的线程切换到另一个进程中的线程,会引起线程切换</li><li>系统开销<br>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I&#x2F;O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</li><li>通信方面<br>线程间可以通过直接读写同一进程的数据进行通信,但进程间通信需要IPC</li></ul><h2 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h2><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%88%87%E6%8D%A2.png" style="zoom:80%;" /><ul><li>就绪状态(ready):等待被调度</li><li>运行状态(running)</li><li>阻塞状态(waiting):等待资源<br>应该注意以下内容:<ul><li>只有就绪态和运行态可以相互转换,其他都是单向转换.就绪状态的进程通过调度算法从而获得CPU时间,转为运行状态;而运行状态的进程,在分配给他的CPU时间片用完之后就会转为就绪状态,等待下一次调用</li><li>阻塞状态是缺少需要的资源从而由运行状态转换而来,但是该资源不包括CPU时间,缺少CPU时间会从运行态转换为就绪态</li></ul></li></ul><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><ul><li><strong>不同环境的调度算法不同,因此需要针对不同的环境来讨论调度算法</strong></li></ul><h3 id="进程调度策略"><a href="#进程调度策略" class="headerlink" title="进程调度策略"></a>进程调度策略</h3><ul><li><h3 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务(FCFS)"></a>先来先服务(FCFS)</h3><ul><li>先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</li></ul><h3 id="短作业-进程-优先-SJ-P-F"><a href="#短作业-进程-优先-SJ-P-F" class="headerlink" title="短作业(进程)优先(SJ(P)F)"></a><strong>短作业(进程)优先</strong>(SJ(P)F)</h3><ul><li>短作业(进程)优先调度算法SJ(P)F，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。</li></ul><h3 id="高优先权优先（FPF）"><a href="#高优先权优先（FPF）" class="headerlink" title="高优先权优先（FPF）"></a>高优先权优先（FPF）</h3><ul><li>为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。</li></ul><h4 id="非抢占式优先权"><a href="#非抢占式优先权" class="headerlink" title="非抢占式优先权"></a>非抢占式优先权</h4><ul><li>在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</li></ul><h4 id="抢占式优先权"><a href="#抢占式优先权" class="headerlink" title="抢占式优先权"></a>抢占式优先权</h4><ul><li>在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程i 时，就将其优先权Pi与正在执行的进程j 的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi&gt;Pj，则立即停止Pj的执行，做进程切换，使i 进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li><p>容易出现优先级倒置现象：优先级反转是指一个低优先级的任务持有一个被高优先级任务所需要的共享资源。高优先任务由于因资源缺乏而处于受阻状态，一直等到低优先级任务释放资源为止。而低优先级获得的CPU时间少，如果此时有优先级处于两者之间的任务，并且不需要那个共享资源，则该中优先级的任务反而超过这两个任务而获得CPU时间。如果高优先级等待资源时不是阻塞等待，而是忙循环，则可能永远无法获得资源，因为此时低优先级进程无法与高优先级进程争夺CPU时间，从而无法执行，进而无法释放资源，造成的后果就是高优先级任务无法获得资源而继续推进。</p></li><li><p>解决方案</p><ul><li>设置优先级上限，给临界区一个高优先级，进入临界区的进程都将获得这个高优先级，如果其他试图进入临界区的进程的优先级都低于这个高优先级，那么优先级反转就不会发生。</li><li>优先级继承，当一个高优先级进程等待一个低优先级进程持有的资源时，低优先级进程将暂时获得高优先级进程的优先级别，在释放共享资源后，低优先级进程回到原来的优先级别。嵌入式系统VxWorks就是采用这种策略。</li><li>临界区禁止中断，通过禁止中断来保护临界区，采用此种策略的系统只有两种优先级：可抢占优先级和中断禁止优先级。前者为一般进程运行时的优先级，后者为运行于临界区的优先级。火星探路者正是由于在临界区中运行的气象任务被中断发生的通信任务所抢占才导致故障，如果有临界区的禁止中断保护，此一问题也不会发生。</li></ul></li></ul><h3 id="高响应比优先"><a href="#高响应比优先" class="headerlink" title="高响应比优先"></a>高响应比优先</h3><ul><li><p>在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：</p><ul><li><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95.png" alt="高响应比优先调度算法"></li></ul></li><li><p>在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。</p></li></ul><h3 id="时间片轮转法"><a href="#时间片轮转法" class="headerlink" title="时间片轮转法"></a>时间片轮转法</h3><ul><li>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言之，系统能在给定的时间内响应所有用户的请求。</li></ul><h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><ul><li>前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述。<ul><li>应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。</li><li>当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n 队列便采取按时间片轮转的方式运行。</li><li>仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第i队列中的进程运行。如果处理机正在第i队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先权进程。</li></ul></li></ul><h3 id="批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？"><a href="#批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？" class="headerlink" title="批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？"></a><strong>批处理系统、分时系统和实时系统中，各采用哪几种进程（作业）调度算法？</strong></h3><ul><li>批处理系统常用调度算法：<ul><li>先来先服务</li><li>最短作业优先</li><li>最短剩余时间优先</li><li>响应比最高者优先</li></ul></li><li>分时系统调度算法：<ul><li>轮转调度</li><li>优先级调度</li><li>多级队列调度</li><li>彩票调度</li></ul></li><li>实时系统调度算法：<ul><li>单比率调度</li><li>限期调度</li><li>最少裕度法</li></ul></li></ul></li></ul><h3 id="Linux调度算法CFS"><a href="#Linux调度算法CFS" class="headerlink" title="Linux调度算法CFS"></a>Linux调度算法CFS</h3><ul><li>2.6后开始采用该算法，该算法按优先级分配时间片的比例，记录每个线程的执行时间，如果有一个进程执行时间不到它分配的比例，则优先执行该进程</li><li>对于实时进程：使用SCHED_FIFO和SCHED_RR(Round Robin)两种，对于普通进程使用CFS,等级最高的为FIIO,这种进程除非自己让出CPU或者被更高级别的FIFO或RR抢占,否则Linux会一直执行它。RR只是这种线程中的同级别FIFO的平均分配。只有实时进程主动让出或执行完毕后，普通进程才有机会执行。</li></ul><h3 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h3><p><strong>批处理系统没有太多的用户操作,在该系统中,调度算法目标是保证吞吐量和周转时间(从提交到终止的时间)</strong></p><ul><li>1.1 先来先服务(first-come first-serverd(FCFS )<br>按照请求的顺序进行调度。<br>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</li><li>1.2 短作业优先(shortest job first(SJF))<br>按估计运行时间最短的顺序进行调度</li><li>1.3 最短剩余时间优先(shortest remaining time next (SRTN))<br>按估计剩余时间最短的顺序进行排序</li></ul><h3 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h3><p><strong>交互式系统有大量的用户交互操作,在该系统中调度算法的目标是快速地进行响应</strong></p><ul><li>2.1 时间片轮转<br>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。<br>时间轮转算法的效率和时间片的大小有很大的关系<ul><li>因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间</li><li>而如果时间片时间太长,那么实时性就得不到保证</li></ul></li><li>2.2 优先级调度<br>为每个进程分配一个优先级,按优先级进行调度<br>为了防止优先级低的进程永远得不到调度,可以随着时间的推移增加等待进程的优先级</li><li>2.3 多级反馈队列<br>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。<br>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。<br>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</li></ul><h2 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h2><p>实时系统要求一个请求在一个确定的时间内得到响应分为y硬实时和软实时,前者必须满足绝对的截止时间,后者可以容忍一定的超时</p><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><ul><li>硬中断</li><li>软中断</li></ul><h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><h2 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1. 临界区"></a>1. 临界区</h2><p>每个进程中,对临界资源进行访问的代码称为临界区(临界资源是一次仅允许一个进程使用的共享资源)<br>为了互斥访问临界区资源,每个进程在进入临界区之前,需要先进行检查.</p><h2 id="2-同步和互斥"><a href="#2-同步和互斥" class="headerlink" title="2.同步和互斥"></a>2.同步和互斥</h2><ul><li>同步:多个线程按一定顺序执行</li><li>互斥:多个线程在同一时刻只有一个线程能进入临界区</li></ul><h2 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3.信号量"></a>3.信号量</h2><ul><li>信号量(Semaphore)是一个整形变量,可以对其执行down和up操作,也就是常见的P和V操作<ul><li>down:如果信号量大于0,执行-1操作;如果信号量等于0,j进程睡眠,等待信号量大于0.</li><li>up:对信号量执行+1操作,唤醒睡眠的进程让其完成down操作.</li></ul></li><li>down 和 up 操作需要被设计成原语,通常的做法是执行这些操作时,屏蔽中断.如果信号量只有1和0,那么就成为了互斥量(Mutex),0表示临界区已经枷锁,1表示临界区已经解锁</li></ul><blockquote><p>原语:若干个机器指令构成的完成某种特定功能的一段程序，具有不可分割性·即原语的执行必须是连续的，在执行过程中不允许被中断。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> semaphore<span class="token punctuation">;</span>semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 临界区</span>    <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">P2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 临界区</span>    <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用信号量实现生产者-消费者问题"><a href="#使用信号量实现生产者-消费者问题" class="headerlink" title="使用信号量实现生产者 - 消费者问题"></a>使用信号量实现生产者 - 消费者问题</h3><p>问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p><ul><li>为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</li><li>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty &#x3D; 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">N</span> <span class="token expression"><span class="token number">100</span></span></span><span class="token keyword">typedef</span> <span class="token keyword">int</span> semaphore<span class="token punctuation">;</span>semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>semaphore empty <span class="token operator">=</span> N<span class="token punctuation">;</span>semaphore full <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> item <span class="token operator">=</span> <span class="token function">produce_item</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">insert_item</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> item <span class="token operator">=</span> <span class="token function">remove_item</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">consume_item</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><ul><li>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</li><li>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</li></ul><pre class="line-numbers language-Pascal" data-language="Pascal"><code class="language-Pascal">    monitor ProducerConsumer    integer i;    condition c;    procedure insert();    begin        &#x2F;&#x2F; ...    end;    procedure remove();    begin        &#x2F;&#x2F; ...    end;end monitor;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><ul><li>读者-写者问题<br>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</li><li>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">int</span> semaphore<span class="token punctuation">;</span><span class="token comment">//互斥量,对count加锁</span>semaphore count_mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//互斥量,对读写的数据加锁</span>semaphore data_mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//进行读操作的进程数量</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span>        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>count_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data_mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><ul><li>进程同步与进程通信很容易混淆，它们的区别在于：<ol><li>进程同步：控制多个进程按一定顺序执行；</li><li>进程通信：进程间传输信息。</li></ol></li><li>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</li></ul><h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1. 管道"></a>1. 管道</h3><ul><li>管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。<ul><li>pipe函数:linux中</li></ul></li><li>限制:<ul><li>只支持半双工通信(单向交替传输)</li><li>只能在父子进程中使用<img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/%E7%AE%A1%E9%81%93.png"/></li></ul></li></ul><h3 id="2-FIFO"><a href="#2-FIFO" class="headerlink" title="2.FIFO"></a>2.FIFO</h3><ul><li>也成为命名管道,去除了管道只能在父子线程中使用的限制</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">mkfifo</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token class-name">mode_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mkfifoat</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token class-name">mode_t</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>FIFO常用于客户-服务器应用程序中,FIFO用作汇聚点,在客户进程和服务器进程之间传递数据<img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/FIFO.png" style="zoom:75%;" /></li></ul><h3 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3.消息队列"></a>3.消息队列</h3><ul><li>相比于FIFO,消息队列具有以下特点<ul><li>消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；</li><li>避免了FIFO的同步阻塞问题,不需要进程自己提供同步方法</li><li>读进程可以根据消息类型有选择地接收消息,而不像FIFO那样只能默认地接收</li></ul></li></ul><h3 id="4-信号量"><a href="#4-信号量" class="headerlink" title="4.信号量"></a>4.信号量</h3><p>它是一个计数器,用于为多个进程提供共享数据对象的访问</p><h3 id="5-共享存储"><a href="#5-共享存储" class="headerlink" title="5.共享存储"></a>5.共享存储</h3><ul><li>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</li><li>需要使用信号量用来同步对共享存储的访问。</li><li>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用使用内存的匿名段.</li></ul><h3 id="6-套接字"><a href="#6-套接字" class="headerlink" title="6.套接字"></a>6.套接字</h3><ul><li>与其它通信机制不同的是，它可用于不同机器间的进程通信。</li></ul><h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><ul><li><p>一个良好的计算机程序 常常具有良好的局部性，也就是说，它们倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身</p></li><li><p>时间局部性</p><ul><li>时间局部性是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。强调数据的重复访问。利用时间局部性，缓存在现代程序系统中扮演着重要角色，数据缓存，磁盘缓存，文件缓存等，极大提高数据的重复访问性能。</li></ul></li><li><p>空间局部性</p><ul><li>空间局部性是指一旦程序访问了某个存储单元，则不久之后。其附近的存储单元也将被访问。强调连续空间数据的访问，一般顺序访问每个元素（步长为1）时具有最好的空间局部性，步长越大，空间局部性越差。</li></ul></li></ul><h2 id="磁盘预读"><a href="#磁盘预读" class="headerlink" title="磁盘预读"></a>磁盘预读</h2><ul><li>计算机系统是分页读取和存储的，一般一页为4kb,每次读取和存储的最小单元为一页，而<strong>磁盘预读时通常会读取页的整倍数</strong></li></ul><h2 id="存储层次"><a href="#存储层次" class="headerlink" title="存储层次"></a>存储层次</h2><ul><li><p><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1.png" alt="img"></p></li><li><p>寄存器：最快的访问</p></li><li><p>高速缓存(L1~L3:SRAM):高速缓存钟的访问速度为纳秒级，非常快</p><ul><li>第一级高速缓存（L1）：通常访问只需要几个周期，通常是几十个kb</li><li>第二级高速缓存（L2）：比L1约有2到10倍较高延迟性，通常是几百个kb或更多</li><li>第三级高速缓存（L3）：不一定有，比L2更高的延迟性，通常由数MB之大</li><li>第四级高速缓存（L4）：不普遍，CPU外部的DRAM，但速度较主存高</li></ul></li><li><p>主存(DRAM)：访问需要几百个周期，容量非常大，持久化保存数据</p></li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><ul><li><p>为了解决互相打扰的问题</p><ul><li>虚拟空间多大：寻址空间—-64位系统 2^64byte</li><li>内存映射：偏移量+段的基地址&#x3D;线性地址（虚拟空间）</li><li>线性地址通过OS和MMU（Merory Management Unit）来映射到真正的物理地址</li></ul></li><li><p>特征</p><ul><li>一个以上的虚拟地址可以指向同一个物理内存地址。</li><li>虚拟内存空间可大于实际可用的物理地址。</li></ul></li><li><p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p></li><li><p>虚拟内存被分为用户空间和内核空间两部分，当我们在用户态的时候，只能访问用户空间。只有进入内核态，才能访问内核空间</p></li></ul><h4 id="虚拟页"><a href="#虚拟页" class="headerlink" title="虚拟页"></a>虚拟页</h4><ul><li>把内存分成固定大小的页框(4k) ,把硬盘上的程序也分成4k大小的块，用到那一块加载那一块，加载过程中，如果内存已满，会把最不常用的一块放到swap分区。（LRU算法 Least Recently Used 力扣146）</li><li>系统将虚拟内存分割为称为虚拟页(Virtual Page,VP)的大小固定的块，每个虚拟页的大小为P &#x3D; 2^p字节，类似地，物理内存被分割为物理页(Physical Page,PP)，大小也为P字节（物理页也称为页帧(page frame)）。</li><li>任意时刻，虚拟页面都分为互不相交的三种：<ul><li>未分配的：系统还未分配（或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间</li><li>未缓存的：没有缓存在物理存储器中的已分配页</li><li>缓存的：当前缓存在物理存储器中的已分配页</li></ul></li></ul><h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><ul><li><p>页表是一种特殊的数据结构，存放着各个虚拟页的状态，是否映射，是否缓存.。</p></li><li><p>页表的每一个表项分为两部分，</p><ul><li>第一部分记录此页是否在物理内存上</li><li>第二部分记录物理内存页的地址(如果在的话)。当进程访问某个虚拟地址，就会先去看页表，如果发现对应的数据不在物理内存中，则发生<strong>缺页异常</strong>。</li></ul></li><li><p><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/v2-bfdac094ce8bea2ddc2838ed94a8ff90_720w.jpg" alt="img"></p></li><li><p>图中展示了一个页表的基本组织结构，页表就是一个页表条目(Page Table Entry,PTE)的数组，每个PTE由一个有效位(valid bit)和一个地址组成，有效位表明了该虚拟页当前是否存在于物理内存中，如果有效位是1，该PTE中就会存储物理内存中相应的物理页的起始地址。如果有效位是0，且PTE中的地址为null，这表示这个虚拟页还未被分配，而如果有效位是0且PTE中有地址，那么这个地址指向该虚拟页在磁盘上的起始位置</p><p>上图的示例展示了一个有8个虚拟页和4个物理页的系统的页表，四个虚拟页（VP1、VP2、VP4和VP7）当前存储于物理内存中，两个页（VP0和VP5）还未被分配（也就是什么都没存的虚拟内存，在磁盘和物理内存中都不存在这个空间），而剩下的页（VP3和VP6）已经被分配了，但是还未缓存进物理内存（也就是存在于磁盘上）</p><p>在上面的过程中，CPU读包含在VP1中的一个数据时，地址翻译硬件将虚拟地址作为一个索引找到页表中的PTE 2，然后再从PTE 2中保存的物理地址从真正的物理内存中读到这个数据，在有效位为1的PTE中成功找到对应的物理页就称之为页命中</p></li></ul><h4 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h4><ul><li>调用内核缺页异常处理程序。内核通过页面置换算法选择一个页面作为被覆盖的页面，将该页的内容刷新到磁盘空间当中。然后把VP3映射的磁盘文件缓存到该物理页上面。然后页表中第三条，有效位变成1，第二部分存储上了可以对应物理内存页的地址的内容。</li></ul><h2 id="CPUCache"><a href="#CPUCache" class="headerlink" title="CPUCache"></a>CPUCache</h2><ul><li>CPU Cache 通常分为三级缓存：L1 Cache、L2 Cache、L3 Cache，级别越低的离 CPU 核心越近，访问速度也快，但是存储容量相对就会越小。其中，在多核心的 CPU 里，每个核心都有各自的 L1&#x2F;L2 Cache，而 L3 Cache 是所有核心共享使用的。</li></ul><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/CPUCache.png" alt="CPUCache" style="zoom:50%;" /><ul><li>CPU Cache 是由很多个 Cache Line 组成的，CPU Line 是 CPU 从内存读取数据的基本单位，而 CPU Line 是由各种标志（Tag）+ 数据块（Data Block）组成</li></ul><h3 id="CacheLine"><a href="#CacheLine" class="headerlink" title="CacheLine"></a>CacheLine</h3><ul><li><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/CacheLine.png" alt="CacheLine" style="zoom: 50%;" /></li><li>CPU Line 是 CPU 从内存读取数据的基本单位，而 CPU Line 是由各种标志（Tag）+ 数据块（Data Block）组成</li></ul><h3 id="写直达"><a href="#写直达" class="headerlink" title="写直达"></a>写直达</h3><ul><li><p>保持内存与 Cache 一致性最简单的方式是，<strong>把数据同时写入内存和 Cache 中</strong>，这种方法称为<strong>写直达（*Write Through*）</strong>。</p></li><li><p>在这个方法里，写入前会先判断数据是否已经在 CPU Cache 里面了：</p><ul><li>如果数据已经在 Cache 里面，先将数据更新到 Cache 里面，再写入到内存里面；</li><li>如果数据没有在 Cache 里面，就直接把数据更新到内存里面。</li></ul></li><li><p>写直达法很直观，也很简单，但是问题明显，无论数据在不在 Cache 里面，每次写操作都会写回到内存，这样写操作将会花费大量的时间，无疑性能会受到很大的影响。</p></li></ul><h3 id="写回"><a href="#写回" class="headerlink" title="写回"></a>写回</h3><ul><li><strong>当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block「被替换」时才需要写到内存中</strong></li><li>如果当发生写操作时，数据已经在 CPU Cache 里的话，则把数据更新到 CPU Cache 里，同时标记 CPU Cache 里的这个 Cache Block 为脏（Dirty）的，这个脏的标记代表这个时候，我们 CPU Cache 里面的这个 Cache Block 的数据和内存是不一致的，这种情况是不用把数据写到内存里的；</li><li>如果当发生写操作时，数据所对应的 Cache Block 里存放的是「别的内存地址的数据」的话，就要检查这个 Cache Block 里的数据有没有被标记为脏的，如果是脏的话，我们就要把这个 Cache Block 里的数据写回到内存，然后再把当前要写入的数据，写入到这个 Cache Block 里，同时也把它标记为脏的；如果 Cache Block 里面的数据没有被标记为脏，则就直接将数据写入到这个 Cache Block 里，然后再把这个 Cache Block 标记为脏的就好了。</li></ul><h3 id="写传播"><a href="#写传播" class="headerlink" title="写传播"></a>写传播</h3><ul><li>某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为<strong>写传播（*Wreite Propagation*）</strong></li></ul><h3 id="事务串行化"><a href="#事务串行化" class="headerlink" title="事务串行化"></a>事务串行化</h3><ul><li>某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为<strong>事务的串形化（*Transaction Serialization*）</strong>。</li><li>解释<ul><li>假设我们有一个含有 4 个核心的 CPU，这 4 个核心都操作共同的变量 i（初始值为 0 ）。A 号核心先把 i 值变为 100，而此时同一时间，B 号核心先把 i 值变为 200，这里两个修改，都会「传播」到 C 和 D 号核心。</li><li><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/%E4%BA%8B%E5%8A%A1%E4%B8%B2%E8%A1%8C%E5%8C%96.png" alt="事务串行化" style="zoom: 50%;" /></li><li>那么问题就来了，C 号核心先收到了 A 号核心更新数据的事件，再收到 B 号核心更新数据的事件，因此 C 号核心看到的变量 i 是先变成 100，后变成 200。</li><li>而如果 D 号核心收到的事件是反过来的，则 D 号核心看到的是变量 i 先变成 200，再变成 100，虽然是做到了写传播，但是各个 Cache 里面的数据还是不一致的。</li><li>所以，我们要保证 C 号核心和 D 号核心都能看到<strong>相同顺序的数据变化</strong>，比如变量 i 都是先变成 100，再变成 200，这样的过程就是事务的串形化。</li><li>要实现事务串形化，要做到 2 点：<ul><li>CPU 核心对于 Cache 中数据的操作，需要同步给其他 CPU 核心；</li><li>要引入「锁」的概念，如果两个 CPU 核心里有相同数据的 Cache，那么对于这个 Cache 数据的更新，只有拿到了「锁」，才能进行对应的数据更新。</li></ul></li></ul></li></ul><h3 id="总线嗅探"><a href="#总线嗅探" class="headerlink" title="总线嗅探"></a>总线嗅探</h3><ul><li>写传播的原则就是当某个 CPU 核心更新了 Cache 中的数据，要把该事件广播通知到其他核心。最常见实现的方式是<strong>总线嗅探（*Bus Snooping*）</strong>。</li></ul><h3 id="缓存一致性协议：MESI"><a href="#缓存一致性协议：MESI" class="headerlink" title="缓存一致性协议：MESI"></a>缓存一致性协议：MESI</h3><ol><li><p>概念：**<code>MESI</code>**（<code>Modified Exclusive Shared Or Invalid</code>）(也称为伊利诺斯协议，是因为该协议由伊利诺斯州立大学提出）是一种广泛使用的支持写回策略的缓存一致性协议</p></li><li><p>MESI的状态</p><p>CPU中每个缓存行（<code>caceh line</code>)使用4种状态进行标记（使用额外的两位(<code>bit</code>)表示):</p><p><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/1014100-20180613224959895-380715655.gif" alt="img"></p><ol><li><p><strong>M: 被修改（Modified)</strong></p><p>该缓存行只被缓存在该<code>CPU</code>的缓存中，并且是被修改过的（<code>dirty</code>),即与主存中的数据不一致，该缓存行中的内存需要在未来的某个时间点（允许其它<code>CPU</code>读取请主存中相应内存之前）写回（<code>write back</code>）主存。</p><p>当被写回主存之后，该缓存行的状态会变成独享（<code>exclusive</code>)状态</p></li><li><p><strong>E:独占的(Exclusive)</strong></p><p>该缓存行只被缓存在该<code>CPU</code>的缓存中，它是未被修改过的（<code>clean</code>)，与主存中数据一致。该状态可以在任何时刻当有其它<code>CPU</code>读取该内存时变成共享状态（<code>shared</code>)。</p><p>同样地，当<code>CPU</code>修改该缓存行中内容时，该状态可以变成<code>Modified</code>状态</p></li><li><p><strong>S:共享的(Shared)</strong><br>该状态意味着该缓存行可能被多个<code>CPU</code>缓存，并且各个缓存中的数据与主存数据一致（<code>clean</code>)，当有一个<code>CPU</code>修改该缓存行中，其它<code>CPU</code>中该缓存行可以被作废（变成无效状态（<code>Invalid</code>））</p></li><li><p><strong>无效的(Invalid)</strong></p><p>该缓存是无效的（可能有其它<code>CPU</code>修改了该缓存行）。</p></li><li><p><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/1014100-20180613225133544-1986197420.png" alt="img"></p></li></ol></li><li><p>解释</p><ol><li><p>在一个典型系统中，可能会有几个缓存（在多核系统中，每个核心都会有自己的缓存）共享主存总线，每个相应的<code>CPU</code>会发出读写请求，而缓存的目的是为了减少<code>CPU</code>读写共享主存的次数。</p></li><li><p>一个缓存除在<code>Invalid</code>状态外都可以满足cpu的读请求，一个<code>Invalid</code>的缓存行必须从主存中读取（变成<code>S</code>或者 <code>E</code>状态）来满足该<code>CPU</code>的读请求。</p></li><li><p>一个写请求只有在该缓存行是M或者E状态时才能被执行，如果缓存行处于<code>S</code>状态，必须先将其它缓存中该缓存行变成<code>Invalid</code>状态（也既是不允许不同<code>CPU</code>同时修改同一缓存行，即使修改该缓存行中不同位置的数据也不允许）。该操作经常作用广播的方式来完成，例如：<code>RequestFor Ownership</code> (<code>RFO</code>)。</p></li><li><p>缓存可以随时将一个非M状态的缓存行作废，或者变成<code>Invalid</code>状态，而一个<code>M</code>状态的缓存行必须先被写回主存。</p></li><li><p>一个处于<code>M</code>状态的缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S状态之前被延迟执行。</p></li><li><p>一个处于S状态的缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（<code>Invalid</code>）。</p></li><li><p>一个处于E状态的缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成<code>S</code>状态。</p></li><li><p>对于<code>M</code>和<code>E</code>状态而言总是精确的，他们在和该缓存行的真正状态是一致的。而<code>S</code>状态可能是非一致的，如果一个缓存将处于<code>S</code>状态的缓存行作废了，而另一个缓存实际上可能已经独享了该缓存行，但是该缓存却不会将该缓存行升迁为<code>E</code>状态，这是因为其它缓存不会广播他们作废掉该缓存行的通知，同样由于缓存并没有保存该缓存行的<code>copy</code>的数量，因此（即使有这种通知）也没有办法确定自己是否已经独享了该缓存行。</p><p>从上面的意义看来E状态是一种投机性的优化：如果一个<code>CPU</code>想修改一个处于<code>S</code>状态的缓存行，总线事务需要将所有该缓存行的<code>copy</code>变成<code>Invalid</code>状态，而修改<code>E</code>状态的缓存不需要使用总线事务</p></li></ol></li></ol><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><h3 id="四次拷贝的情况"><a href="#四次拷贝的情况" class="headerlink" title="四次拷贝的情况"></a>四次拷贝的情况</h3><ul><li><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/%E5%9B%9B%E6%AC%A1%E6%8B%B7%E8%B4%9D%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="img"></li></ul><h3 id="零拷贝的两种实现方式"><a href="#零拷贝的两种实现方式" class="headerlink" title="零拷贝的两种实现方式"></a>零拷贝的两种实现方式</h3><h4 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap+write"></a>mmap+write</h4><ul><li>mmap<ul><li>在LINUX中我们可以使用mmap用来在进程虚拟内存地址空间中分配地址空间，创建和物理内存的映射关系</li><li><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/mmap%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="img"></li><li>使用mmap后的文件拷贝流程</li><li><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/mmap%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E6%B5%81%E7%A8%8B.png" alt="img"></li><li>应用进程调用了 <code>mmap()</code> 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；</li><li>应用进程再调用 <code>write()</code>，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；</li><li>最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。</li></ul></li></ul><h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h4><ul><li>在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 <code>sendfile()</code>,<ul><li>它可以替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用</li><li>该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝</li></ul></li><li><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/sendfile%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E6%B5%81%E7%A8%8B1.png" alt="img"></li></ul><h4 id="SG-DMA"><a href="#SG-DMA" class="headerlink" title="SG-DMA"></a><strong>SG-DMA</strong></h4><ul><li><p>但是这还<strong>不是真正的零拷贝技术</strong>，如果网卡支持 <strong>SG-DMA</strong>（The Scatter-Gather Direct Memory Access）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。</p></li><li><p>ethtool -k eth0  | grep scatter-gather    :查明是否支持scatter-gather</p></li><li><p>从 Linux 内核 <code>2.4</code> 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， <code>sendfile()</code> 系统调用的过程发生了点变化，具体过程如下:</p><ul><li>第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；</li><li>第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；</li></ul></li><li><p><img src="https://raw.githubusercontent.com/X-Leonidas/picRepository/main/img/sendfile%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E6%B5%81%E7%A8%8B2.png"></p></li><li><p><strong>零拷贝（*Zero-copy*）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</strong></p></li><li><p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，<strong>只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</strong></p><p>所以，总体来看，<strong>零拷贝技术可以把文件传输的性能提高至少一倍以上</strong>。</p></li></ul><h3 id="大文件传输"><a href="#大文件传输" class="headerlink" title="大文件传输"></a>大文件传输</h3><ul><li><p>针对大文件的传输，不应该使用 PageCache，也就是说不应该使用零拷贝技术，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache，这样在高并发的环境下，会带来严重的性能问题</p></li><li><p><strong>在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I&#x2F;O + 直接 I&#x2F;O」来替代零拷贝技术</strong>。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
